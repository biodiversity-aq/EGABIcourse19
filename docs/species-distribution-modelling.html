<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>13 Species distribution modelling | SCAR-EGABI Tools for Southern Ocean Spatial Analysis and Modelling</title>
  <meta name="description" content="Course material" />
  <meta name="generator" content="bookdown 0.12 and GitBook 2.6.7" />

  <meta property="og:title" content="13 Species distribution modelling | SCAR-EGABI Tools for Southern Ocean Spatial Analysis and Modelling" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Course material" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="13 Species distribution modelling | SCAR-EGABI Tools for Southern Ocean Spatial Analysis and Modelling" />
  
  <meta name="twitter:description" content="Course material" />
  

<meta name="author" content="Anton Van de Putte, Charlène Guillaumot, Grant Humphries, Huw Griffiths, Ben Raymond, Ryan Reisinger" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="recent-and-past-application-of-sdms.html">
<link rel="next" href="sdm-algorithms.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/kePrint-0.0.1/kePrint.js"></script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> About this</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#technical-stuff"><i class="fa fa-check"></i>Technical stuff</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="course-schedule.html"><a href="course-schedule.html"><i class="fa fa-check"></i><b>2</b> Course schedule</a><ul>
<li class="chapter" data-level="2.1" data-path="course-schedule.html"><a href="course-schedule.html#monday"><i class="fa fa-check"></i><b>2.1</b> Monday</a></li>
<li class="chapter" data-level="2.2" data-path="course-schedule.html"><a href="course-schedule.html#tuesday"><i class="fa fa-check"></i><b>2.2</b> Tuesday</a></li>
<li class="chapter" data-level="2.3" data-path="course-schedule.html"><a href="course-schedule.html#wednesday"><i class="fa fa-check"></i><b>2.3</b> Wednesday</a></li>
<li class="chapter" data-level="2.4" data-path="course-schedule.html"><a href="course-schedule.html#thursday"><i class="fa fa-check"></i><b>2.4</b> Thursday</a></li>
<li class="chapter" data-level="2.5" data-path="course-schedule.html"><a href="course-schedule.html#friday"><i class="fa fa-check"></i><b>2.5</b> Friday</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="course-introduction.html"><a href="course-introduction.html"><i class="fa fa-check"></i><b>3</b> Course Introduction</a></li>
<li class="chapter" data-level="4" data-path="overview.html"><a href="overview.html"><i class="fa fa-check"></i><b>4</b> Overview</a><ul>
<li class="chapter" data-level="4.1" data-path="overview.html"><a href="overview.html#preparation"><i class="fa fa-check"></i><b>4.1</b> Preparation</a></li>
<li class="chapter" data-level="4.2" data-path="overview.html"><a href="overview.html#taxonomy"><i class="fa fa-check"></i><b>4.2</b> Taxonomy</a></li>
<li class="chapter" data-level="4.3" data-path="overview.html"><a href="overview.html#occurrences"><i class="fa fa-check"></i><b>4.3</b> Occurrences</a></li>
<li class="chapter" data-level="4.4" data-path="overview.html"><a href="overview.html#environmental-data"><i class="fa fa-check"></i><b>4.4</b> Environmental data</a></li>
<li class="chapter" data-level="4.5" data-path="overview.html"><a href="overview.html#fit-model"><i class="fa fa-check"></i><b>4.5</b> Fit model</a></li>
<li class="chapter" data-level="4.6" data-path="overview.html"><a href="overview.html#predict-from-model"><i class="fa fa-check"></i><b>4.6</b> Predict from model</a></li>
<li class="chapter" data-level="4.7" data-path="overview.html"><a href="overview.html#other-bits-and-pieces"><i class="fa fa-check"></i><b>4.7</b> Other bits and pieces</a><ul>
<li class="chapter" data-level="4.7.1" data-path="overview.html"><a href="overview.html#place-names"><i class="fa fa-check"></i><b>4.7.1</b> Place names</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="introduction-to-r-and-the-tidyverse.html"><a href="introduction-to-r-and-the-tidyverse.html"><i class="fa fa-check"></i><b>5</b> Introduction to R and the Tidyverse</a><ul>
<li class="chapter" data-level="5.1" data-path="introduction-to-r-and-the-tidyverse.html"><a href="introduction-to-r-and-the-tidyverse.html#exercise-r-script"><i class="fa fa-check"></i><b>5.1</b> Exercise R script</a></li>
<li class="chapter" data-level="5.2" data-path="introduction-to-r-and-the-tidyverse.html"><a href="introduction-to-r-and-the-tidyverse.html#see-also"><i class="fa fa-check"></i><b>5.2</b> See also</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="open-data-and-data-cleaning.html"><a href="open-data-and-data-cleaning.html"><i class="fa fa-check"></i><b>6</b> Open data and data cleaning</a><ul>
<li class="chapter" data-level="6.1" data-path="open-data-and-data-cleaning.html"><a href="open-data-and-data-cleaning.html#fair-principles"><i class="fa fa-check"></i><b>6.1</b> FAIR principles</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="metadata-darwin-core.html"><a href="metadata-darwin-core.html"><i class="fa fa-check"></i><b>7</b> Metadata - Darwin Core</a><ul>
<li class="chapter" data-level="7.1" data-path="metadata-darwin-core.html"><a href="metadata-darwin-core.html#darwin-core-structure"><i class="fa fa-check"></i><b>7.1</b> Darwin Core structure</a></li>
<li class="chapter" data-level="7.2" data-path="metadata-darwin-core.html"><a href="metadata-darwin-core.html#types-of-darwin-core-archives"><i class="fa fa-check"></i><b>7.2</b> Types of Darwin Core archives</a></li>
<li class="chapter" data-level="7.3" data-path="metadata-darwin-core.html"><a href="metadata-darwin-core.html#darwin-core-details"><i class="fa fa-check"></i><b>7.3</b> Darwin Core details</a><ul>
<li class="chapter" data-level="7.3.1" data-path="metadata-darwin-core.html"><a href="metadata-darwin-core.html#required-metadata-fields"><i class="fa fa-check"></i><b>7.3.1</b> Required metadata fields:</a></li>
<li class="chapter" data-level="7.3.2" data-path="metadata-darwin-core.html"><a href="metadata-darwin-core.html#citation-auto-generation"><i class="fa fa-check"></i><b>7.3.2</b> Citation auto generation</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="metadata-darwin-core.html"><a href="metadata-darwin-core.html#metadata-for-occurrence-data"><i class="fa fa-check"></i><b>7.4</b> Metadata for occurrence data</a><ul>
<li class="chapter" data-level="7.4.1" data-path="metadata-darwin-core.html"><a href="metadata-darwin-core.html#what"><i class="fa fa-check"></i><b>7.4.1</b> What</a></li>
<li class="chapter" data-level="7.4.2" data-path="metadata-darwin-core.html"><a href="metadata-darwin-core.html#where"><i class="fa fa-check"></i><b>7.4.2</b> Where</a></li>
<li class="chapter" data-level="7.4.3" data-path="metadata-darwin-core.html"><a href="metadata-darwin-core.html#when"><i class="fa fa-check"></i><b>7.4.3</b> When</a></li>
<li class="chapter" data-level="7.4.4" data-path="metadata-darwin-core.html"><a href="metadata-darwin-core.html#who"><i class="fa fa-check"></i><b>7.4.4</b> Who</a></li>
<li class="chapter" data-level="7.4.5" data-path="metadata-darwin-core.html"><a href="metadata-darwin-core.html#how"><i class="fa fa-check"></i><b>7.4.5</b> How</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="biological-data.html"><a href="biological-data.html"><i class="fa fa-check"></i><b>8</b> Biological data</a><ul>
<li class="chapter" data-level="8.1" data-path="biological-data.html"><a href="biological-data.html#taxonomy-1"><i class="fa fa-check"></i><b>8.1</b> Taxonomy</a></li>
<li class="chapter" data-level="8.2" data-path="biological-data.html"><a href="biological-data.html#other-packages"><i class="fa fa-check"></i><b>8.2</b> Other packages</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="environmental-data-1.html"><a href="environmental-data-1.html"><i class="fa fa-check"></i><b>9</b> Environmental data</a><ul>
<li class="chapter" data-level="9.1" data-path="environmental-data-1.html"><a href="environmental-data-1.html#bowerbirdblueant"><i class="fa fa-check"></i><b>9.1</b> Bowerbird/blueant</a><ul>
<li class="chapter" data-level="9.1.1" data-path="environmental-data-1.html"><a href="environmental-data-1.html#available-data-sets"><i class="fa fa-check"></i><b>9.1.1</b> Available data sets</a></li>
<li class="chapter" data-level="9.1.2" data-path="environmental-data-1.html"><a href="environmental-data-1.html#usage"><i class="fa fa-check"></i><b>9.1.2</b> Usage</a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="environmental-data-1.html"><a href="environmental-data-1.html#raadtools"><i class="fa fa-check"></i><b>9.2</b> RAADtools</a></li>
<li class="chapter" data-level="9.3" data-path="environmental-data-1.html"><a href="environmental-data-1.html#other-useful-packages"><i class="fa fa-check"></i><b>9.3</b> Other useful packages</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="mapping.html"><a href="mapping.html"><i class="fa fa-check"></i><b>10</b> Mapping</a><ul>
<li class="chapter" data-level="10.1" data-path="mapping.html"><a href="mapping.html#maps-in-r"><i class="fa fa-check"></i><b>10.1</b> Maps in R</a><ul>
<li class="chapter" data-level="10.1.1" data-path="mapping.html"><a href="mapping.html#exercises"><i class="fa fa-check"></i><b>10.1.1</b> Exercises</a></li>
<li class="chapter" data-level="10.1.2" data-path="mapping.html"><a href="mapping.html#lets-use-the-maps-data"><i class="fa fa-check"></i><b>10.1.2</b> Let’s use the maps data!</a></li>
</ul></li>
<li class="chapter" data-level="10.2" data-path="mapping.html"><a href="mapping.html#somap"><i class="fa fa-check"></i><b>10.2</b> SOmap</a><ul>
<li class="chapter" data-level="10.2.1" data-path="mapping.html"><a href="mapping.html#circumpolar-maps"><i class="fa fa-check"></i><b>10.2.1</b> Circumpolar maps</a></li>
<li class="chapter" data-level="10.2.2" data-path="mapping.html"><a href="mapping.html#non-circumpolar-maps"><i class="fa fa-check"></i><b>10.2.2</b> Non-circumpolar maps</a></li>
<li class="chapter" data-level="10.2.3" data-path="mapping.html"><a href="mapping.html#plotting-via-ggplot2"><i class="fa fa-check"></i><b>10.2.3</b> Plotting via ggplot2</a></li>
<li class="chapter" data-level="10.2.4" data-path="mapping.html"><a href="mapping.html#modifying-map-objects-advanced-usage"><i class="fa fa-check"></i><b>10.2.4</b> Modifying map objects (advanced usage)</a></li>
</ul></li>
<li class="chapter" data-level="10.3" data-path="mapping.html"><a href="mapping.html#supporting-data-for-maps"><i class="fa fa-check"></i><b>10.3</b> Supporting data for maps</a><ul>
<li class="chapter" data-level="10.3.1" data-path="mapping.html"><a href="mapping.html#quantarcticr"><i class="fa fa-check"></i><b>10.3.1</b> quantarcticR</a></li>
<li class="chapter" data-level="10.3.2" data-path="mapping.html"><a href="mapping.html#antanym"><i class="fa fa-check"></i><b>10.3.2</b> antanym</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="11" data-path="data-visualisation.html"><a href="data-visualisation.html"><i class="fa fa-check"></i><b>11</b> Data visualisation</a></li>
<li class="chapter" data-level="12" data-path="recent-and-past-application-of-sdms.html"><a href="recent-and-past-application-of-sdms.html"><i class="fa fa-check"></i><b>12</b> Recent and past application of SDMs</a></li>
<li class="chapter" data-level="13" data-path="species-distribution-modelling.html"><a href="species-distribution-modelling.html"><i class="fa fa-check"></i><b>13</b> Species distribution modelling</a><ul>
<li class="chapter" data-level="13.1" data-path="species-distribution-modelling.html"><a href="species-distribution-modelling.html#sdm-introduction-and-review"><i class="fa fa-check"></i><b>13.1</b> SDM introduction and review</a><ul>
<li class="chapter" data-level="13.1.1" data-path="species-distribution-modelling.html"><a href="species-distribution-modelling.html#references"><i class="fa fa-check"></i><b>13.1.1</b> References</a></li>
</ul></li>
<li class="chapter" data-level="13.2" data-path="species-distribution-modelling.html"><a href="species-distribution-modelling.html#sdm-outputs"><i class="fa fa-check"></i><b>13.2</b> SDM outputs</a><ul>
<li class="chapter" data-level="13.2.1" data-path="species-distribution-modelling.html"><a href="species-distribution-modelling.html#references-1"><i class="fa fa-check"></i><b>13.2.1</b> References</a></li>
</ul></li>
<li class="chapter" data-level="13.3" data-path="species-distribution-modelling.html"><a href="species-distribution-modelling.html#calibration"><i class="fa fa-check"></i><b>13.3</b> Calibration</a><ul>
<li class="chapter" data-level="13.3.1" data-path="species-distribution-modelling.html"><a href="species-distribution-modelling.html#references-2"><i class="fa fa-check"></i><b>13.3.1</b> References</a></li>
</ul></li>
<li class="chapter" data-level="13.4" data-path="species-distribution-modelling.html"><a href="species-distribution-modelling.html#exercise-scripts"><i class="fa fa-check"></i><b>13.4</b> Exercise scripts</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="sdm-algorithms.html"><a href="sdm-algorithms.html"><i class="fa fa-check"></i><b>14</b> SDM algorithms</a><ul>
<li class="chapter" data-level="14.1" data-path="sdm-algorithms.html"><a href="sdm-algorithms.html#exercises---practice-with-models"><i class="fa fa-check"></i><b>14.1</b> Exercises - Practice with models</a><ul>
<li class="chapter" data-level="14.1.1" data-path="sdm-algorithms.html"><a href="sdm-algorithms.html#load-and-clean-the-data"><i class="fa fa-check"></i><b>14.1.1</b> Load and clean the data</a></li>
<li class="chapter" data-level="14.1.2" data-path="sdm-algorithms.html"><a href="sdm-algorithms.html#one-hot-encoding"><i class="fa fa-check"></i><b>14.1.2</b> One hot encoding!</a></li>
<li class="chapter" data-level="14.1.3" data-path="sdm-algorithms.html"><a href="sdm-algorithms.html#the-models"><i class="fa fa-check"></i><b>14.1.3</b> The models</a></li>
<li class="chapter" data-level="14.1.4" data-path="sdm-algorithms.html"><a href="sdm-algorithms.html#regression-problem"><i class="fa fa-check"></i><b>14.1.4</b> Regression problem</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="15" data-path="sdm-extra-bits-and-pieces.html"><a href="sdm-extra-bits-and-pieces.html"><i class="fa fa-check"></i><b>15</b> SDM extra bits and pieces</a><ul>
<li class="chapter" data-level="15.1" data-path="sdm-extra-bits-and-pieces.html"><a href="sdm-extra-bits-and-pieces.html#spatial-partial-predictions"><i class="fa fa-check"></i><b>15.1</b> Spatial partial predictions</a><ul>
<li class="chapter" data-level="15.1.1" data-path="sdm-extra-bits-and-pieces.html"><a href="sdm-extra-bits-and-pieces.html#example-1"><i class="fa fa-check"></i><b>15.1.1</b> Example</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="16" data-path="other-r-resources-for-southern-oceanantarctic-use.html"><a href="other-r-resources-for-southern-oceanantarctic-use.html"><i class="fa fa-check"></i><b>16</b> Other R resources for Southern Ocean/Antarctic use</a><ul>
<li class="chapter" data-level="16.1" data-path="other-r-resources-for-southern-oceanantarctic-use.html"><a href="other-r-resources-for-southern-oceanantarctic-use.html#diet-data-sohungry"><i class="fa fa-check"></i><b>16.1</b> Diet data: sohungry</a></li>
<li class="chapter" data-level="16.2" data-path="other-r-resources-for-southern-oceanantarctic-use.html"><a href="other-r-resources-for-southern-oceanantarctic-use.html#allometric-equations-solong"><i class="fa fa-check"></i><b>16.2</b> Allometric equations: solong</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">SCAR-EGABI Tools for Southern Ocean Spatial Analysis and Modelling</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="species-distribution-modelling" class="section level1">
<h1><span class="header-section-number">13</span> Species distribution modelling</h1>
<p>Exercise scripts are at the bottom of this page.</p>
<div id="sdm-introduction-and-review" class="section level2">
<h2><span class="header-section-number">13.1</span> SDM introduction and review</h2>
<p>What are species distribution models?</p>
<p><a href="./course_material/Course%201%20Tuesday%20What_are_SDM.pdf">Presentation (PDF)</a></p>
<div id="references" class="section level3">
<h3><span class="header-section-number">13.1.1</span> References</h3>
<ul>
<li><a href="./course_material/literature/Araujo%20_%20Guisan2006.pdf">Araujo and Guisan 2006</a></li>
<li><a href="./course_material/literature/Elith%202006.pdf">Elith 2006</a></li>
<li><a href="./course_material/literature/Elith%20and%20Leathwick%202009.pdf">Elith and Leathwick 2009</a></li>
<li><a href="./course_material/literature/guisan%20and%20zimmermann%202000.pdf">Guisan and Zimmermann 2000</a></li>
<li><a href="./course_material/literature/Peterson%202011.pdf">Peterson 2011</a></li>
<li><a href="./course_material/literature/Soberon%20Peterson%202005.pdf">Soberon and Peterson 2005</a></li>
</ul>
</div>
</div>
<div id="sdm-outputs" class="section level2">
<h2><span class="header-section-number">13.2</span> SDM outputs</h2>
<p>Understand and generate SDM outputs.</p>
<p><a href="./course_material/Course%203%20Tuesday_%20SDM%20outputs.pdf">Presentation (PDF)</a></p>
<div id="references-1" class="section level3">
<h3><span class="header-section-number">13.2.1</span> References</h3>
<ul>
<li><a href="./course_material/literature/Elith_et_al-2010.pdf">Elith et al. 2010</a></li>
<li><a href="./course_material/literature/Guillaumot%20et%20al%202018-Ecology_and_Evolution.pdf">Guillaumot et al. 2018 Ecol &amp; Evol</a></li>
<li><a href="./course_material/literature/liu%202013.pdf">Liu et al. 2013</a></li>
<li><a href="./course_material/literature/Torres%202015.PDF">Torres 2015</a></li>
</ul>
</div>
</div>
<div id="calibration" class="section level2">
<h2><span class="header-section-number">13.3</span> Calibration</h2>
<p>What you should know before running a model.</p>
<p><a href="./course_material/Course%205%20Calibration-%20all%20you%20should%20think%20about%20before%20running%20a%20model.pdf">Presentation (PDF)</a></p>
<div id="references-2" class="section level3">
<h3><span class="header-section-number">13.3.1</span> References</h3>
<ul>
<li><a href="./course_material/literature/Appendix%20S1%20Elith%202008.pdf">Appendix S1 Elith 2008</a></li>
<li><a href="./course_material/literature/Barbet-Massin_et_al-2012.pdf">Barbet-Massin et al. 2012</a></li>
<li><a href="./course_material/literature/Barve%202011.pdf">Barve 2011</a></li>
<li><a href="./course_material/literature/Boria%202014.pdf">Boria 2014</a></li>
<li><a href="./course_material/literature/Brotons%202004.pdf">Brotons 2004</a></li>
<li><a href="./course_material/literature/Elith_et_al-2008.pdf">Elith et al. 2008</a></li>
<li><a href="./course_material/literature/Elith_et_al-2010.pdf">Elith et al. 2010</a></li>
<li><a href="./course_material/literature/Guillaumot%20et%20al%202018-Ecology_and_Evolution.pdf">Guillaumot et al. 2018 Ecol &amp; Evol</a></li>
<li><a href="./course_material/literature/Guillaumot%20et%20al.%202019_%20Progress%20in%20Oceano.pdf">Guillaumot et al. 2019</a></li>
<li><a href="./course_material/literature/Guillaumot%20et%20al%202018%20MEPS%20final%20version.pdf">Guillaumot et al. 2018 MEPS</a></li>
<li><a href="./course_material/literature/Muscarella_et_al-2014-Methods_in_Ecology_and_Evolution.pdf">Muscarella et al. 2014</a></li>
<li><a href="./course_material/literature/Phillips%202009.pdf">Phillips et al. 2009</a></li>
<li><a href="./course_material/literature/Wisz%20Guisan%202009.pdf">Wisz and Guisan 2009</a></li>
</ul>
</div>
</div>
<div id="exercise-scripts" class="section level2">
<h2><span class="header-section-number">13.4</span> Exercise scripts</h2>
<p><a href="./course_material/exercises/scripts/EXERCISE.docx">EXERCISE.docx</a></p>
<p><a href="./course_material/exercises/scripts/calibration_BRT.R">calibration_BRT.R</a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">#### Open environmental data and occurrences (run_yOur_SDM.R file)
<span class="co">#---------------------------------------------------------</span>
<span class="co"># compute there the MATRIX_OCC_ENVI variable (1 set)</span>
<span class="co"># in the run_yOur_SDM.R file, run until the MyFold definition </span>
<span class="co"># for set.seed(1) (j=1)</span>
<span class="co"># run the model and compare the predictive deviance according to the set of parameters chosen</span>
<span class="co">#=============================================================</span>
<span class="kw">source</span>(<span class="st">&quot;scripts/Function_gbm.R&quot;</span>)
tc=<span class="dv">4</span>   <span class="co"># tree complexity</span>
lr=<span class="fl">0.011</span> <span class="co"># learning rate</span>
bf=<span class="fl">0.8</span> <span class="co"># bag fraction</span>

model.res&lt;-<span class="st"> </span><span class="kw">gbm.step_v2</span> (<span class="dt">data=</span>MATRIX_OCC_ENVI, 
                         <span class="dt">gbm.x =</span> <span class="dv">2</span><span class="op">:</span><span class="kw">ncol</span>(MATRIX_OCC_ENVI),
                         <span class="dt">gbm.y =</span> <span class="dv">1</span>,
                         <span class="dt">family =</span> <span class="st">&quot;bernoulli&quot;</span>,
                         <span class="dt">n.folds=</span><span class="dv">4</span>,
                         <span class="dt">fold.vector =</span> MyFold, 
                         <span class="dt">tree.complexity =</span> tc,
                         <span class="dt">learning.rate =</span> lr,
                         <span class="dt">bag.fraction =</span>bf)

model1&lt;-model.res  <span class="co"># tc3 lr0.001 bf=0.8 nbt 10000</span>
model2&lt;-model.res  <span class="co"># tc4 lr0.001 bf=0.8 nbt 10000 </span>
model3&lt;-model.res  <span class="co"># tc4 lr0.005 bf=0.8 nbt 10000 </span>
model4&lt;-model.res  <span class="co"># tc3 lr0.005 bf=0.8 nbt 10000 </span>
model5&lt;-model.res  <span class="co"># tc4 lr0.01 bf=0.8 nbt 10000 </span>
model6&lt;-model.res  <span class="co"># tc4 lr0.008 bf=0.8 nbt 10000 </span>
model7&lt;-model.res  <span class="co"># tc4 lr0.005 bf=0.9 nbt 10000 </span>
model8&lt;-model.res  <span class="co"># tc4 lr0.011 bf=0.8 nbt 10000 </span>


<span class="co"># GENERATE THE PLOTS </span>
tree.list1 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">100</span>, model1<span class="op">$</span>gbm.call<span class="op">$</span>best.trees, <span class="dt">by =</span> <span class="dv">100</span>)
tree.list2 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">100</span>, model2<span class="op">$</span>gbm.call<span class="op">$</span>best.trees, <span class="dt">by =</span> <span class="dv">100</span>)
tree.list3 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">100</span>, model3<span class="op">$</span>gbm.call<span class="op">$</span>best.trees, <span class="dt">by =</span> <span class="dv">100</span>)
tree.list4 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">100</span>, model4<span class="op">$</span>gbm.call<span class="op">$</span>best.trees, <span class="dt">by =</span> <span class="dv">100</span>)
tree.list5 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">100</span>, model5<span class="op">$</span>gbm.call<span class="op">$</span>best.trees, <span class="dt">by =</span> <span class="dv">100</span>)
tree.list6 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">100</span>, model6<span class="op">$</span>gbm.call<span class="op">$</span>best.trees, <span class="dt">by =</span> <span class="dv">100</span>)
tree.list7 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">100</span>, model7<span class="op">$</span>gbm.call<span class="op">$</span>best.trees, <span class="dt">by =</span> <span class="dv">100</span>)
tree.list8 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">100</span>, model8<span class="op">$</span>gbm.call<span class="op">$</span>best.trees, <span class="dt">by =</span> <span class="dv">100</span>)

pred1 &lt;-<span class="st"> </span><span class="kw">predict.gbm</span>(model1,MATRIX_OCC_ENVI, <span class="dt">n.trees =</span> tree.list1, <span class="st">&quot;response&quot;</span>)
pred2 &lt;-<span class="st"> </span><span class="kw">predict.gbm</span>(model2,MATRIX_OCC_ENVI, <span class="dt">n.trees =</span> tree.list2, <span class="st">&quot;response&quot;</span>)
pred3 &lt;-<span class="st"> </span><span class="kw">predict.gbm</span>(model3,MATRIX_OCC_ENVI, <span class="dt">n.trees =</span> tree.list3, <span class="st">&quot;response&quot;</span>)
pred4 &lt;-<span class="st"> </span><span class="kw">predict.gbm</span>(model4,MATRIX_OCC_ENVI, <span class="dt">n.trees =</span> tree.list4, <span class="st">&quot;response&quot;</span>)
pred5 &lt;-<span class="st"> </span><span class="kw">predict.gbm</span>(model5,MATRIX_OCC_ENVI, <span class="dt">n.trees =</span> tree.list5, <span class="st">&quot;response&quot;</span>)
pred6 &lt;-<span class="st"> </span><span class="kw">predict.gbm</span>(model6,MATRIX_OCC_ENVI, <span class="dt">n.trees =</span> tree.list6, <span class="st">&quot;response&quot;</span>)
pred7 &lt;-<span class="st"> </span><span class="kw">predict.gbm</span>(model7,MATRIX_OCC_ENVI, <span class="dt">n.trees =</span> tree.list7, <span class="st">&quot;response&quot;</span>)
pred8 &lt;-<span class="st"> </span><span class="kw">predict.gbm</span>(model8,MATRIX_OCC_ENVI, <span class="dt">n.trees =</span> tree.list8, <span class="st">&quot;response&quot;</span>)

graphe.deviance1 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">max</span>(tree.list1)<span class="op">/</span><span class="dv">100</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(graphe.deviance1)) {
  graphe.deviance1 [i] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(MATRIX_OCC_ENVI<span class="op">$</span>id, pred1[,i],<span class="dt">calc.mean=</span>T)
}
graphe.deviance2 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">max</span>(tree.list2)<span class="op">/</span><span class="dv">100</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(graphe.deviance2)) {
  graphe.deviance2 [i] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(MATRIX_OCC_ENVI<span class="op">$</span>id, pred2[,i],<span class="dt">calc.mean=</span>T)
}
graphe.deviance3 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">max</span>(tree.list3)<span class="op">/</span><span class="dv">100</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(graphe.deviance3)) {
  graphe.deviance3 [i] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(MATRIX_OCC_ENVI<span class="op">$</span>id, pred3[,i],<span class="dt">calc.mean=</span>T)
}
graphe.deviance4 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">max</span>(tree.list4)<span class="op">/</span><span class="dv">100</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(graphe.deviance4)) {
  graphe.deviance4 [i] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(MATRIX_OCC_ENVI<span class="op">$</span>id, pred4[,i],<span class="dt">calc.mean=</span>T)
}
graphe.deviance5 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">max</span>(tree.list5)<span class="op">/</span><span class="dv">100</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(graphe.deviance5)) {
  graphe.deviance5 [i] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(MATRIX_OCC_ENVI<span class="op">$</span>id, pred5[,i],<span class="dt">calc.mean=</span>T)
}
graphe.deviance6 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">max</span>(tree.list6)<span class="op">/</span><span class="dv">100</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(graphe.deviance6)) {
  graphe.deviance6 [i] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(MATRIX_OCC_ENVI<span class="op">$</span>id, pred6[,i],<span class="dt">calc.mean=</span>T)
}
graphe.deviance7 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">max</span>(tree.list7)<span class="op">/</span><span class="dv">100</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(graphe.deviance7)) {
  graphe.deviance7 [i] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(MATRIX_OCC_ENVI<span class="op">$</span>id, pred7[,i],<span class="dt">calc.mean=</span>T)
}
graphe.deviance8 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">max</span>(tree.list8)<span class="op">/</span><span class="dv">100</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(graphe.deviance8)) {
  graphe.deviance8 [i] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(MATRIX_OCC_ENVI<span class="op">$</span>id, pred8[,i],<span class="dt">calc.mean=</span>T)
}

<span class="kw">par</span>(<span class="dt">mai=</span><span class="kw">c</span>(<span class="fl">0.5</span>,<span class="fl">0.5</span>,<span class="fl">0.5</span>,<span class="fl">0.5</span>))
<span class="kw">plot</span>(tree.list1,graphe.deviance1,<span class="dt">xlim =</span> <span class="kw">c</span>(<span class="op">-</span><span class="dv">100</span>,<span class="dv">4000</span>), <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>),<span class="dt">type=</span><span class="st">&#39;l&#39;</span>, <span class="dt">xlab =</span> <span class="st">&quot;number of trees&quot;</span>,<span class="dt">ylab =</span> <span class="st">&quot;predictive deviance&quot;</span>, <span class="dt">cex.lab =</span> <span class="fl">1.5</span>) 
<span class="kw">lines</span>(tree.list2,graphe.deviance2,<span class="dt">col=</span><span class="st">&quot;blue&quot;</span>)
<span class="kw">lines</span>(tree.list3,graphe.deviance3,<span class="dt">col=</span><span class="st">&quot;red&quot;</span>)
<span class="kw">lines</span>(tree.list4,graphe.deviance4,<span class="dt">col=</span><span class="st">&quot;green&quot;</span>)
<span class="kw">lines</span>(tree.list5,graphe.deviance5,<span class="dt">col=</span><span class="st">&quot;orange&quot;</span>)
<span class="kw">lines</span>(tree.list6,graphe.deviance6,<span class="dt">col=</span><span class="st">&quot;pink&quot;</span>)
<span class="kw">lines</span>(tree.list7,graphe.deviance7,<span class="dt">col=</span><span class="st">&quot;deepskyblue&quot;</span>)
<span class="kw">lines</span>(tree.list8,graphe.deviance8,<span class="dt">col=</span><span class="st">&quot;purple&quot;</span>)
<span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>,<span class="dt">legend=</span><span class="kw">c</span>(<span class="st">&quot;tc3 lr0.001 bf=0.8&quot;</span>,<span class="st">&quot;tc4 lr0.001 bf=0.8&quot;</span>,<span class="st">&quot;tc4 lr0.005 bf=0.8 &quot;</span>,<span class="st">&quot;tc3 lr0.005 bf=0.8&quot;</span>,<span class="st">&quot;tc4 lr0.01 bf=0.8&quot;</span>,<span class="st">&quot;tc4 lr0.008 bf=0.8&quot;</span>,<span class="st">&quot;tc4 lr0.005 bf=0.9&quot;</span>,<span class="st">&quot;tc4 lr0.011 bf=0.8&quot;</span>),<span class="dt">col=</span><span class="kw">c</span>(<span class="st">&quot;black&quot;</span>,<span class="st">&quot;blue&quot;</span>,<span class="st">&quot;red&quot;</span>,<span class="st">&quot;green&quot;</span>,<span class="st">&quot;orange&quot;</span>,<span class="st">&quot;pink&quot;</span>,<span class="st">&quot;deepskyblue&quot;</span>,<span class="st">&quot;purple&quot;</span>),<span class="dt">pch=</span><span class="dv">16</span>,<span class="dt">cex=</span><span class="fl">0.7</span>)</code></pre></div>
<p><a href="./course_material/exercises/scripts/clock4_crossValidation.R">clock4_crossValidation.R</a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">clock4 &lt;-<span class="st"> </span><span class="cf">function</span>(occ, bg.coords){
  <span class="co"># the spatial sampling aims at defining areas containing either test or training data </span>
  <span class="co"># for the CLOCK-4 method, 4 triangle areas are defined, cutting the Southern Ocean circle into 4 equal areas. Three of these 4 areas contain the data that will be used to train the model, the other remaining one, the data that will be used to test the model after predictions </span>
  <span class="co"># the areas used to train and test the model are randomly defined at each loop step </span>
  
  <span class="co">#initialise vectors that are used to generate the spatial sampling structure</span>
  random_longA &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">179</span>,<span class="dv">1</span>)
  random_longB &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">180</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)
  random_longC &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">180</span>,<span class="dv">1</span>)
  random_longD &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">179</span>,<span class="dv">0</span>,<span class="dv">1</span>)
  random_long &lt;-<span class="st"> </span><span class="kw">c</span>(random_longA,random_longB,random_longC,random_longD)
  
  <span class="co"># sample a number between -180 and 180 to define the random sampling transect </span>
  tirage &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">seq</span>(<span class="dv">181</span>,<span class="dv">541</span>,<span class="dv">1</span>),<span class="dv">1</span>)
  random_long_tirage &lt;-<span class="st"> </span>random_long[tirage]
  random_long_tirage_A1 &lt;-<span class="st"> </span>random_long[tirage<span class="op">+</span><span class="dv">90</span>]
  random_long_tirage_A2 &lt;-<span class="st"> </span>random_long[tirage<span class="op">+</span><span class="dv">180</span>]
  random_long_tirage_A3 &lt;-<span class="st"> </span>random_long[tirage<span class="op">-</span><span class="dv">90</span>]
  <span class="co">#random_long_tirage_A4 &lt;- random_long[tirage-180]</span>
  

  ## define training and test groups (composed of both presence and background data)
  occ.grp &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">nrow</span>(occ))
  bg.coords.grp &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">nrow</span>(bg.coords))
  
  ## define training and test groups (composed of both presence and background data)
  presence_tot &lt;-<span class="st"> </span>occ
  background_data &lt;-<span class="st"> </span>bg.coords
  training_presences.occ1 &lt;-<span class="st"> </span><span class="ot">NA</span>;training_presences.occ3 &lt;-<span class="ot">NA</span>
  training_presences.occ1_part1 &lt;-<span class="st"> </span><span class="ot">NA</span>;training_presences.occ3_part1 &lt;-<span class="ot">NA</span>
  training_presences.occ1_part2 &lt;-<span class="st"> </span><span class="ot">NA</span>;training_presences.occ3_part2 &lt;-<span class="ot">NA</span>
  training_backgr.occ1 &lt;-<span class="st"> </span><span class="ot">NA</span>; training_backgr.occ3 &lt;-<span class="st"> </span><span class="ot">NA</span>
  training_backgr.occ1_part1 &lt;-<span class="st"> </span><span class="ot">NA</span>; training_backgr.occ3_part1 &lt;-<span class="st"> </span><span class="ot">NA</span>
  training_backgr.occ1_part2 &lt;-<span class="st"> </span><span class="ot">NA</span>; training_backgr.occ3_part2 &lt;-<span class="st"> </span><span class="ot">NA</span>
  training_presences.occ2 &lt;-<span class="st"> </span><span class="ot">NA</span>;training_presences.occ4 &lt;-<span class="st"> </span><span class="ot">NA</span>
  training_presences.occ2_part1 &lt;-<span class="st"> </span><span class="ot">NA</span>;training_presences.occ4_part1 &lt;-<span class="st"> </span><span class="ot">NA</span>
  training_presences.occ2_part2 &lt;-<span class="st"> </span><span class="ot">NA</span>;training_presences.occ4_part2 &lt;-<span class="st"> </span><span class="ot">NA</span>
  training_backgr.occ2 &lt;-<span class="st"> </span><span class="ot">NA</span>;training_backgr.occ4 &lt;-<span class="st"> </span><span class="ot">NA</span>
  training_backgr.occ2_part1 &lt;-<span class="st"> </span><span class="ot">NA</span>;training_backgr.occ4_part1 &lt;-<span class="st"> </span><span class="ot">NA</span>
  training_backgr.occ2_part2 &lt;-<span class="st"> </span><span class="ot">NA</span>;training_backgr.occ4_part2 &lt;-<span class="st"> </span><span class="ot">NA</span>
  
  
  <span class="co">#---------------------</span>
  <span class="co"># TRAINING PRESENCES</span>
  <span class="co">#---------------------</span>
  
  ### ZONE 1 ####
  <span class="cf">if</span> (random_long_tirage <span class="op">&lt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>random_long_tirage_A1 <span class="op">&lt;=</span><span class="dv">0</span>){ <span class="co"># imply that A2 &gt;= 0 and A3&gt;=0</span>
    training_presences.occ1 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A1)
    training_backgr.occ1 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A1)
  } 
  <span class="cf">if</span> (random_long_tirage <span class="op">&gt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>random_long_tirage_A1 <span class="op">&gt;=</span><span class="dv">0</span>){
    training_presences.occ1 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A1)
    training_backgr.occ1 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A1)
  }
  
  <span class="cf">if</span> (random_long_tirage <span class="op">&gt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>random_long_tirage_A1 <span class="op">&lt;=</span><span class="dv">0</span>){
    training_presences.occ1_part1 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span><span class="dv">180</span> )
    training_presences.occ1_part2 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span><span class="op">-</span><span class="dv">180</span> <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A1 )
    training_backgr.occ1_part1 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span><span class="dv">180</span> )
    training_backgr.occ1_part2 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span><span class="op">-</span><span class="dv">180</span> <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A1 )
  }
  
  <span class="cf">if</span> (random_long_tirage <span class="op">&lt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>random_long_tirage_A1 <span class="op">&gt;=</span><span class="dv">0</span>){
    training_presences.occ1_part1 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> )
    training_presences.occ1_part2 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A1 )
    training_backgr.occ1_part1 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> )
    training_backgr.occ1_part2 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A1 )
  }
  
  ### ZONE 2 ####
  
  <span class="cf">if</span> (random_long_tirage_A1 <span class="op">&lt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>random_long_tirage_A2 <span class="op">&lt;=</span><span class="dv">0</span>){
    training_presences.occ2 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A1 <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A2 )
    training_backgr.occ2 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A1 <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A2)
  } 
  <span class="cf">if</span> (random_long_tirage_A1 <span class="op">&gt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>random_long_tirage_A2 <span class="op">&gt;=</span><span class="dv">0</span>){
    training_presences.occ2 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A1 <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A2 )
    training_backgr.occ2 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A1 <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A2)
  }
  
  <span class="cf">if</span> (random_long_tirage_A1 <span class="op">&gt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>random_long_tirage_A2 <span class="op">&lt;=</span><span class="dv">0</span>){
    training_presences.occ2_part1 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A1 <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span><span class="dv">180</span>)
    training_presences.occ2_part2 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span><span class="op">-</span><span class="dv">180</span> <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A2)
    training_backgr.occ2_part1 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A1 <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span><span class="dv">180</span>)
    training_backgr.occ2_part2 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span><span class="op">-</span><span class="dv">180</span> <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A2)
  }
  
  <span class="cf">if</span> (random_long_tirage_A1 <span class="op">&lt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>random_long_tirage_A2 <span class="op">&gt;=</span><span class="dv">0</span>){
    training_presences.occ2_part1 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A1 <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> )
    training_presences.occ2_part2 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A2 )
    training_backgr.occ2_part1 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A1 <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> )
    training_backgr.occ2_part2 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A2 )
  }
  
  ### ZONE 3 ####
  <span class="cf">if</span> (random_long_tirage_A2 <span class="op">&lt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>random_long_tirage_A3 <span class="op">&lt;=</span><span class="dv">0</span>){
    training_presences.occ3 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A2 <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A3 )
    training_backgr.occ3 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A2 <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A3)
  } 
  <span class="cf">if</span> (random_long_tirage_A2 <span class="op">&gt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>random_long_tirage_A3 <span class="op">&gt;=</span><span class="dv">0</span>){
    training_presences.occ3 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A2 <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A3 )
    training_backgr.occ3 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A2 <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A3)
  }
  
  <span class="cf">if</span> (random_long_tirage_A2 <span class="op">&gt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>random_long_tirage_A3 <span class="op">&lt;=</span><span class="dv">0</span>){
    training_presences.occ3_part1 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A2 <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span><span class="dv">180</span> )
    training_presences.occ3_part2 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span><span class="op">-</span><span class="dv">180</span> <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A3 )
    training_backgr.occ3_part1 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A2 <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span><span class="dv">180</span> )
    training_backgr.occ3_part2 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span><span class="op">-</span><span class="dv">180</span> <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A3 )
  }
  
  <span class="cf">if</span> (random_long_tirage_A2 <span class="op">&lt;=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>random_long_tirage_A3 <span class="op">&gt;=</span><span class="dv">0</span>){
    training_presences.occ3_part1 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A2 <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> )
    training_presences.occ3_part2 &lt;-<span class="st"> </span><span class="kw">which</span>(presence_tot[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>presence_tot[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A3 )
    training_backgr.occ3_part1 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span>random_long_tirage_A2 <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> )
    training_backgr.occ3_part2 &lt;-<span class="st"> </span><span class="kw">which</span>(background_data[,<span class="dv">1</span>] <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>background_data[,<span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>random_long_tirage_A3 )
  }
  
  ### set the groups 
  training_presence_grp1_all &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">na.omit</span>(<span class="kw">c</span>(training_presences.occ1,training_presences.occ1_part1,training_presences.occ1_part2)))
  training_presence_grp2_all &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">na.omit</span>(<span class="kw">c</span>(training_presences.occ2,training_presences.occ2_part1,training_presences.occ2_part2)))
  training_presence_grp3_all &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">na.omit</span>(<span class="kw">c</span>(training_presences.occ3,training_presences.occ3_part1,training_presences.occ3_part2)))


  <span class="cf">for</span> (i <span class="cf">in</span> training_presence_grp1_all){
    occ.grp[i] &lt;-<span class="st"> </span><span class="dv">1</span>
  }
  <span class="cf">for</span> (i <span class="cf">in</span> training_presence_grp2_all){
    occ.grp[i] &lt;-<span class="st"> </span><span class="dv">2</span>
  }
  <span class="cf">for</span> (i <span class="cf">in</span> training_presence_grp3_all){
    occ.grp[i] &lt;-<span class="st"> </span><span class="dv">3</span>
  }
  occ.grp[<span class="kw">which</span>(<span class="kw">is.na</span>(occ.grp))]=<span class="dv">4</span>
  
  
  training_backgr_grp1_all &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">na.omit</span>(<span class="kw">c</span>(training_backgr.occ1,training_backgr.occ1_part1,training_backgr.occ1_part2)))
  training_backgr_grp2_all &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">na.omit</span>(<span class="kw">c</span>(training_backgr.occ2,training_backgr.occ2_part1,training_backgr.occ2_part2)))
  training_backgr_grp3_all &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">na.omit</span>(<span class="kw">c</span>(training_backgr.occ3,training_backgr.occ3_part1,training_backgr.occ3_part2)))

  <span class="cf">for</span> (i <span class="cf">in</span> training_backgr_grp1_all){
    bg.coords.grp[i] &lt;-<span class="st"> </span><span class="dv">1</span>
  }
  <span class="cf">for</span> (i <span class="cf">in</span> training_backgr_grp2_all){
    bg.coords.grp[i] &lt;-<span class="st"> </span><span class="dv">2</span>
  }
  <span class="cf">for</span> (i <span class="cf">in</span> training_backgr_grp3_all){
    bg.coords.grp[i] &lt;-<span class="st"> </span><span class="dv">3</span>
  }
  bg.coords.grp[<span class="kw">which</span>(<span class="kw">is.na</span>(bg.coords.grp))]=<span class="dv">4</span>
  
  
  out &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">occ.grp=</span>occ.grp,<span class="dt">bg.coords.grp=</span> bg.coords.grp, <span class="dt">tirage=</span>tirage)
  <span class="kw">return</span>(out)
}</code></pre></div>
<p><a href="./course_material/exercises/scripts/Function_gbm.R">Function_gbm.R</a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">### gbm.stepv2

.roc &lt;-<span class="cf">function</span> (obsdat, preddat) {
  <span class="co"># code adapted from Ferrier, Pearce and Watson&#39;s code, by J.Elith</span>
  <span class="co">#</span>
  <span class="co"># see:</span>
  <span class="co"># Hanley, J.A. &amp; McNeil, B.J. (1982) The meaning and use of the area</span>
  <span class="co"># under a Receiver Operating Characteristic (ROC) curve.</span>
  <span class="co"># Radiology, 143, 29-36</span>
  <span class="co">#</span>
  <span class="co"># Pearce, J. &amp; Ferrier, S. (2000) Evaluating the predictive performance</span>
  <span class="co"># of habitat models developed using logistic regression.</span>
  <span class="co"># Ecological Modelling, 133, 225-245.</span>
  <span class="co"># this is the non-parametric calculation for area under the ROC curve, </span>
  <span class="co"># using the fact that a MannWhitney U statistic is closely related to</span>
  <span class="co"># the area</span>
  <span class="co">#</span>
  
  <span class="co"># in dismo, this is used in the gbm routines, but not elsewhere (see evaluate).</span>
  
  <span class="cf">if</span> (<span class="kw">length</span>(obsdat) <span class="op">!=</span><span class="st"> </span><span class="kw">length</span>(preddat)) { 
    <span class="kw">stop</span>(<span class="st">&quot;obs and preds must be equal lengths&quot;</span>)
  }
  n.x &lt;-<span class="st"> </span><span class="kw">length</span>(obsdat[obsdat <span class="op">==</span><span class="st"> </span><span class="dv">0</span>])
  n.y &lt;-<span class="st"> </span><span class="kw">length</span>(obsdat[obsdat <span class="op">==</span><span class="st"> </span><span class="dv">1</span>])
  xy &lt;-<span class="st"> </span><span class="kw">c</span>(preddat[obsdat <span class="op">==</span><span class="st"> </span><span class="dv">0</span>], preddat[obsdat <span class="op">==</span><span class="st"> </span><span class="dv">1</span>])
  rnk &lt;-<span class="st"> </span><span class="kw">rank</span>(xy)
  wilc &lt;-<span class="st"> </span>((n.x <span class="op">*</span><span class="st"> </span>n.y) <span class="op">+</span><span class="st"> </span>((n.x <span class="op">*</span><span class="st"> </span>(n.x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>))<span class="op">/</span><span class="dv">2</span>) <span class="op">-</span><span class="st"> </span><span class="kw">sum</span>(rnk[<span class="dv">1</span><span class="op">:</span>n.x]))<span class="op">/</span>(n.x <span class="op">*</span><span class="st"> </span>n.y)
  <span class="kw">return</span>(<span class="kw">round</span>(wilc, <span class="dv">4</span>))
}


.calibration &lt;-<span class="st"> </span><span class="cf">function</span>(obs, preds, <span class="dt">family =</span> <span class="st">&quot;binomial&quot;</span>)  {
  <span class="co">#</span>
  <span class="co"># j elith/j leathwick 17th March 2005</span>
  <span class="co"># calculates calibration statistics for either binomial or count data</span>
  <span class="co"># but the family argument must be specified for the latter </span>
  <span class="co"># a conditional test for the latter will catch most failures to specify</span>
  <span class="co"># the family</span>
  <span class="co">#</span>
  
  <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
    family &lt;-<span class="st"> &quot;binomial&quot;</span>
  }
  
  pred.range &lt;-<span class="st"> </span><span class="kw">max</span>(preds) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(preds)
  
  <span class="cf">if</span>(pred.range <span class="op">&gt;</span><span class="st"> </span><span class="fl">1.2</span> <span class="op">&amp;</span><span class="st"> </span>family <span class="op">==</span><span class="st"> &quot;binomial&quot;</span>) {
    <span class="kw">print</span>(<span class="kw">paste</span>(<span class="st">&quot;range of response variable is &quot;</span>, <span class="kw">round</span>(pred.range, <span class="dv">2</span>)), <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>, <span class="dt">quote =</span> F)
    <span class="kw">print</span>(<span class="st">&quot;check family specification&quot;</span>, <span class="dt">quote =</span> F)
    <span class="kw">return</span>()
  }
  
  <span class="cf">if</span>(family <span class="op">==</span><span class="st"> &quot;binomial&quot;</span>) {
    pred &lt;-<span class="st"> </span>preds <span class="op">+</span><span class="st"> </span><span class="fl">1e-005</span>
    pred[pred <span class="op">&gt;=</span><span class="st"> </span><span class="dv">1</span>] &lt;-<span class="st"> </span><span class="fl">0.99999</span>
    mod &lt;-<span class="st"> </span><span class="kw">glm</span>(obs <span class="op">~</span><span class="st"> </span><span class="kw">log</span>((pred)<span class="op">/</span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>(pred))), <span class="dt">family =</span> binomial)
    lp &lt;-<span class="st"> </span><span class="kw">log</span>((pred)<span class="op">/</span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>(pred)))
    a0b1 &lt;-<span class="st"> </span><span class="kw">glm</span>(obs <span class="op">~</span><span class="st"> </span><span class="kw">offset</span>(lp) <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">family =</span> binomial)
    miller1 &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">pchisq</span>(a0b1<span class="op">$</span>deviance <span class="op">-</span><span class="st"> </span>mod<span class="op">$</span>deviance, <span class="dv">2</span>)
    ab1 &lt;-<span class="st"> </span><span class="kw">glm</span>(obs <span class="op">~</span><span class="st"> </span><span class="kw">offset</span>(lp), <span class="dt">family =</span> binomial)
    miller2 &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">pchisq</span>(a0b1<span class="op">$</span>deviance <span class="op">-</span><span class="st"> </span>ab1<span class="op">$</span>deviance, <span class="dv">1</span>)
    miller3 &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">pchisq</span>(ab1<span class="op">$</span>deviance <span class="op">-</span><span class="st"> </span>mod<span class="op">$</span>deviance, <span class="dv">1</span>)
  } <span class="cf">else</span> <span class="cf">if</span>(family <span class="op">==</span><span class="st"> &quot;poisson&quot;</span>) {
    mod &lt;-<span class="st"> </span><span class="kw">glm</span>(obs <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(preds), <span class="dt">family =</span> poisson)
    lp &lt;-<span class="st"> </span><span class="kw">log</span>(preds)
    a0b1 &lt;-<span class="st"> </span><span class="kw">glm</span>(obs <span class="op">~</span><span class="st"> </span><span class="kw">offset</span>(lp) <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">family =</span> poisson)
    miller1 &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">pchisq</span>(a0b1<span class="op">$</span>deviance <span class="op">-</span><span class="st"> </span>mod<span class="op">$</span>deviance, <span class="dv">2</span>)
    ab1 &lt;-<span class="st"> </span><span class="kw">glm</span>(obs <span class="op">~</span><span class="st"> </span><span class="kw">offset</span>(lp), <span class="dt">family =</span> poisson)
    miller2 &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">pchisq</span>(a0b1<span class="op">$</span>deviance <span class="op">-</span><span class="st"> </span>ab1<span class="op">$</span>deviance, <span class="dv">1</span>)
    miller3 &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">pchisq</span>(ab1<span class="op">$</span>deviance <span class="op">-</span><span class="st"> </span>mod<span class="op">$</span>deviance, <span class="dv">1</span>)
  }
  
  calibration.result &lt;-<span class="st"> </span><span class="kw">c</span>(mod<span class="op">$</span>coef, miller1, miller2, miller3)
  <span class="kw">names</span>(calibration.result) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;intercept&quot;</span>, <span class="st">&quot;slope&quot;</span>, <span class="st">&quot;testa0b1&quot;</span>, <span class="st">&quot;testa0|b1&quot;</span>, <span class="st">&quot;testb1|a&quot;</span>)
  <span class="kw">return</span>(calibration.result)
}

## VI.
gbm.step_v2 &lt;-<span class="st"> </span><span class="cf">function</span> (data, gbm.x, gbm.y, <span class="dt">offset =</span> <span class="ot">NULL</span>, <span class="dt">fold.vector =</span> <span class="ot">NULL</span>, 
                        <span class="dt">tree.complexity =</span> <span class="dv">1</span>, <span class="dt">learning.rate =</span> <span class="fl">0.01</span>, <span class="dt">bag.fraction =</span> <span class="fl">0.75</span>, 
                        <span class="dt">site.weights =</span> <span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(data)), <span class="dt">var.monotone =</span> <span class="kw">rep</span>(<span class="dv">0</span>, 
                                                                              <span class="kw">length</span>(gbm.x)), 
                        <span class="dt">n.folds =</span> <span class="dv">10</span>, <span class="dt">prev.stratify =</span> <span class="ot">TRUE</span>, <span class="dt">family =</span> <span class="st">&quot;bernoulli&quot;</span>, 
                        <span class="dt">n.trees =</span> <span class="dv">50</span>, <span class="dt">step.size =</span> n.trees, <span class="dt">max.trees =</span> <span class="dv">10000</span>, <span class="dt">tolerance.method =</span> <span class="st">&quot;auto&quot;</span>, 
                        <span class="dt">tolerance =</span> <span class="fl">0.001</span>, <span class="dt">plot.main =</span> <span class="ot">TRUE</span>, <span class="dt">plot.folds =</span> <span class="ot">FALSE</span>, 
                        <span class="dt">verbose =</span> <span class="ot">TRUE</span>, <span class="dt">silent =</span> <span class="ot">FALSE</span>, <span class="dt">keep.fold.models =</span> <span class="ot">FALSE</span>, 
                        <span class="dt">keep.fold.vector =</span> <span class="ot">FALSE</span>, <span class="dt">keep.fold.fit =</span> <span class="ot">FALSE</span>, ...) 
{
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">requireNamespace</span>(<span class="st">&quot;gbm&quot;</span>)) {
    <span class="kw">stop</span>(<span class="st">&quot;you need to install the gbm package to run this function&quot;</span>)
  }
  <span class="kw">requireNamespace</span>(<span class="st">&quot;splines&quot;</span>)
  <span class="cf">if</span> (silent) 
    verbose &lt;-<span class="st"> </span><span class="ot">FALSE</span>
  z1 &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
  x.data &lt;-<span class="st"> </span>data[, gbm.x, drop =<span class="st"> </span><span class="ot">FALSE</span>]
  y.data &lt;-<span class="st"> </span>data[, gbm.y]
  sp.name &lt;-<span class="st"> </span><span class="kw">names</span>(data)[gbm.y]
  <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
    prevalence &lt;-<span class="st"> </span><span class="kw">mean</span>(y.data)
  }
  n.cases &lt;-<span class="st"> </span><span class="kw">nrow</span>(data)
  n.preds &lt;-<span class="st"> </span><span class="kw">length</span>(gbm.x)
  <span class="cf">if</span> (<span class="op">!</span>silent) {
    <span class="kw">cat</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;GBM STEP - version 2.9&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;Performing cross-validation optimisation of a boosted regression tree model </span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;for&quot;</span>, sp.name, <span class="st">&quot;and using a family of&quot;</span>, family, 
        <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;Using&quot;</span>, n.cases, <span class="st">&quot;observations and&quot;</span>, n.preds, <span class="st">&quot;predictors </span><span class="ch">\n</span><span class="st">&quot;</span>)
  }
  <span class="cf">if</span> (<span class="kw">is.null</span>(fold.vector)) {
    <span class="cf">if</span> (prev.stratify <span class="op">&amp;</span><span class="st"> </span>family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
      presence.mask &lt;-<span class="st"> </span>data[, gbm.y] <span class="op">==</span><span class="st"> </span><span class="dv">1</span>
      absence.mask &lt;-<span class="st"> </span>data[, gbm.y] <span class="op">==</span><span class="st"> </span><span class="dv">0</span>
      n.pres &lt;-<span class="st"> </span><span class="kw">sum</span>(presence.mask)
      n.abs &lt;-<span class="st"> </span><span class="kw">sum</span>(absence.mask)
      selector &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n.cases)
      temp &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">seq</span>(<span class="dv">1</span>, n.folds, <span class="dt">by =</span> <span class="dv">1</span>), <span class="dt">length =</span> n.pres)
      temp &lt;-<span class="st"> </span>temp[<span class="kw">order</span>(<span class="kw">runif</span>(n.pres, <span class="dv">1</span>, <span class="dv">100</span>))]
      selector[presence.mask] &lt;-<span class="st"> </span>temp
      temp &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">seq</span>(<span class="dv">1</span>, n.folds, <span class="dt">by =</span> <span class="dv">1</span>), <span class="dt">length =</span> n.abs)
      temp &lt;-<span class="st"> </span>temp[<span class="kw">order</span>(<span class="kw">runif</span>(n.abs, <span class="dv">1</span>, <span class="dv">100</span>))]
      selector[absence.mask] &lt;-<span class="st"> </span>temp
    }
    <span class="cf">else</span> {
      selector &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">seq</span>(<span class="dv">1</span>, n.folds, <span class="dt">by =</span> <span class="dv">1</span>), <span class="dt">length =</span> n.cases)
      selector &lt;-<span class="st"> </span>selector[<span class="kw">order</span>(<span class="kw">runif</span>(n.cases, <span class="dv">1</span>, <span class="dv">100</span>))]
    }
  } <span class="cf">else</span> {
    <span class="cf">if</span> (<span class="kw">length</span>(fold.vector) <span class="op">!=</span><span class="st"> </span>n.cases) {
      <span class="kw">stop</span>(<span class="st">&quot;supplied fold vector is of wrong length&quot;</span>)
    }
    <span class="kw">cat</span>(<span class="st">&quot;loading user-supplied fold vector </span><span class="ch">\n</span><span class="st">&quot;</span>)
    selector &lt;-<span class="st"> </span>fold.vector
  }
  pred.values &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n.cases)
  cv.loss.matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow =</span> n.folds, <span class="dt">ncol =</span> <span class="dv">1</span>)
  training.loss.matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow =</span> n.folds, <span class="dt">ncol =</span> <span class="dv">1</span>)
  trees.fitted &lt;-<span class="st"> </span>n.trees
  model.list &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">paste</span>(<span class="st">&quot;model&quot;</span>, <span class="dv">1</span><span class="op">:</span>n.folds, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>))
  <span class="cf">if</span> (<span class="kw">is.null</span>(offset)) {
    gbm.call &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;gbm::gbm(y.subset ~ .,data=x.subset, n.trees = n.trees, interaction.depth = tree.complexity, shrinkage = learning.rate, bag.fraction = bag.fraction, weights = weight.subset, distribution = as.character(family), var.monotone = var.monotone, verbose = FALSE)&quot;</span>, 
                      <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
  } <span class="cf">else</span> {
    gbm.call &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;gbm::gbm(y.subset ~ . + offset(offset.subset), data=x.subset, n.trees = n.trees, interaction.depth = tree.complexity, shrinkage = learning.rate, bag.fraction = bag.fraction, weights = weight.subset, distribution = as.character(family), var.monotone = var.monotone, verbose = FALSE)&quot;</span>, 
                      <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
  }
  n.fitted &lt;-<span class="st"> </span>n.trees
  y_i &lt;-<span class="st"> </span>y.data
  u_i &lt;-<span class="st"> </span><span class="kw">sum</span>(y.data <span class="op">*</span><span class="st"> </span>site.weights)<span class="op">/</span><span class="kw">sum</span>(site.weights)
  u_i &lt;-<span class="st"> </span><span class="kw">rep</span>(u_i, <span class="kw">length</span>(y_i))
  total.deviance &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(y_i, u_i, <span class="dt">weights =</span> site.weights, 
                                  <span class="dt">family =</span> family, <span class="dt">calc.mean =</span> <span class="ot">FALSE</span>)
  mean.total.deviance &lt;-<span class="st"> </span>total.deviance<span class="op">/</span>n.cases
  tolerance.test &lt;-<span class="st"> </span>tolerance
  <span class="cf">if</span> (tolerance.method <span class="op">==</span><span class="st"> &quot;auto&quot;</span>) {
    tolerance.test &lt;-<span class="st"> </span>mean.total.deviance <span class="op">*</span><span class="st"> </span>tolerance
  }
  <span class="cf">if</span> (<span class="op">!</span>silent) {
    <span class="kw">cat</span>(<span class="st">&quot;creating&quot;</span>, n.folds, <span class="st">&quot;initial models of&quot;</span>, n.trees, 
        <span class="st">&quot;trees&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="cf">if</span> (prev.stratify <span class="op">&amp;</span><span class="st"> </span>family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
      <span class="kw">cat</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;folds are stratified by prevalence&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    } <span class="cf">else</span> {
      <span class="kw">cat</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;folds are unstratified&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    }
    <span class="kw">cat</span>(<span class="st">&quot;total mean deviance = &quot;</span>, <span class="kw">round</span>(mean.total.deviance, 
                                        <span class="dv">4</span>), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;tolerance is fixed at &quot;</span>, <span class="kw">round</span>(tolerance.test, <span class="dv">4</span>), 
        <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="cf">if</span> (tolerance.method <span class="op">!=</span><span class="st"> &quot;fixed&quot;</span> <span class="op">&amp;</span><span class="st"> </span>tolerance.method <span class="op">!=</span><span class="st"> </span>
<span class="st">        &quot;auto&quot;</span>) {
      <span class="kw">stop</span>(<span class="st">&quot;invalid argument for tolerance method - should be auto or fixed&quot;</span>)
    }
  }
  <span class="cf">if</span> (verbose) {
    <span class="kw">cat</span>(<span class="st">&quot;ntrees resid. dev.&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
  }
  
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n.folds) {
    model.mask &lt;-<span class="st"> </span>selector <span class="op">!=</span><span class="st"> </span>i
    pred.mask &lt;-<span class="st"> </span>selector <span class="op">==</span><span class="st"> </span>i
    y.subset &lt;-<span class="st"> </span>y.data[model.mask]
    x.subset &lt;-<span class="st"> </span>x.data[model.mask, , drop =<span class="st"> </span><span class="ot">FALSE</span>]
    weight.subset &lt;-<span class="st"> </span>site.weights[model.mask]
    <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(offset)) {
      offset.subset &lt;-<span class="st"> </span>offset[model.mask]
    }
    <span class="cf">else</span> {
      offset.subset &lt;-<span class="st"> </span><span class="ot">NULL</span>
    }
    model.list[[i]] &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text =</span> gbm.call))
    fitted.values &lt;-<span class="st"> </span>model.list[[i]]<span class="op">$</span>fit
    <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(offset)) {
      fitted.values &lt;-<span class="st"> </span>fitted.values <span class="op">+</span><span class="st"> </span>offset[model.mask]
    }
    <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
      fitted.values &lt;-<span class="st"> </span><span class="kw">exp</span>(fitted.values)<span class="op">/</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(fitted.values))
    }
    <span class="cf">else</span> <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;poisson&quot;</span>) {
      fitted.values &lt;-<span class="st"> </span><span class="kw">exp</span>(fitted.values)
    }
    pred.values[pred.mask] &lt;-<span class="st"> </span>gbm<span class="op">::</span><span class="kw">predict.gbm</span>(model.list[[i]], 
                                               x.data[pred.mask, , <span class="dt">drop =</span> <span class="ot">FALSE</span>], <span class="dt">n.trees =</span> n.trees)
    <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(offset)) {
      pred.values[pred.mask] &lt;-<span class="st"> </span>pred.values[pred.mask] <span class="op">+</span><span class="st"> </span>
<span class="st">        </span>offset[pred.mask]
    }
    <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
      pred.values[pred.mask] &lt;-<span class="st"> </span><span class="kw">exp</span>(pred.values[pred.mask])<span class="op">/</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>
<span class="st">                                                               </span><span class="kw">exp</span>(pred.values[pred.mask]))
    }
    <span class="cf">else</span> <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;poisson&quot;</span>) {
      pred.values[pred.mask] &lt;-<span class="st"> </span><span class="kw">exp</span>(pred.values[pred.mask])
    }
    y_i &lt;-<span class="st"> </span>y.subset
    u_i &lt;-<span class="st"> </span>fitted.values
    weight.fitted &lt;-<span class="st"> </span>site.weights[model.mask]
    training.loss.matrix[i, <span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(y_i, u_i, 
                                                weight.fitted, <span class="dt">family =</span> family)
    y_i &lt;-<span class="st"> </span>y.data[pred.mask]
    u_i &lt;-<span class="st"> </span>pred.values[pred.mask]
    weight.preds &lt;-<span class="st"> </span>site.weights[pred.mask]
    cv.loss.matrix[i, <span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(y_i, u_i, weight.preds, 
                                          <span class="dt">family =</span> family)
  }
  delta.deviance &lt;-<span class="st"> </span><span class="dv">1</span>
  cv.loss.values &lt;-<span class="st"> </span><span class="kw">apply</span>(cv.loss.matrix, <span class="dv">2</span>, mean)
  <span class="cf">if</span> (verbose) {
    <span class="kw">cat</span>(n.fitted, <span class="st">&quot;  &quot;</span>, <span class="kw">round</span>(cv.loss.values, <span class="dv">4</span>), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
  }
  <span class="cf">if</span> (<span class="op">!</span>silent) {
    <span class="kw">cat</span>(<span class="st">&quot;now adding trees...&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
  }
  j &lt;-<span class="st"> </span><span class="dv">1</span>
  <span class="cf">while</span> (delta.deviance <span class="op">&gt;</span><span class="st"> </span>tolerance.test <span class="op">&amp;</span><span class="st"> </span>n.fitted <span class="op">&lt;</span><span class="st"> </span>max.trees) {
    training.loss.matrix &lt;-<span class="st"> </span><span class="kw">cbind</span>(training.loss.matrix, <span class="kw">rep</span>(<span class="dv">0</span>, 
                                                            n.folds))
    cv.loss.matrix &lt;-<span class="st"> </span><span class="kw">cbind</span>(cv.loss.matrix, <span class="kw">rep</span>(<span class="dv">0</span>, n.folds))
    n.fitted &lt;-<span class="st"> </span>n.fitted <span class="op">+</span><span class="st"> </span>step.size
    trees.fitted &lt;-<span class="st"> </span><span class="kw">c</span>(trees.fitted, n.fitted)
    j &lt;-<span class="st"> </span>j <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n.folds) {
      model.mask &lt;-<span class="st"> </span>selector <span class="op">!=</span><span class="st"> </span>i
      pred.mask &lt;-<span class="st"> </span>selector <span class="op">==</span><span class="st"> </span>i
      y.subset &lt;-<span class="st"> </span>y.data[model.mask]
      x.subset &lt;-<span class="st"> </span>x.data[model.mask, , drop =<span class="st"> </span><span class="ot">FALSE</span>]
      weight.subset &lt;-<span class="st"> </span>site.weights[model.mask]
      <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(offset)) {
        offset.subset &lt;-<span class="st"> </span>offset[model.mask]
      }
      model.list[[i]] &lt;-<span class="st"> </span>gbm<span class="op">::</span><span class="kw">gbm.more</span>(model.list[[i]], 
                                       <span class="dt">weights =</span> weight.subset, step.size)
      fitted.values &lt;-<span class="st"> </span>model.list[[i]]<span class="op">$</span>fit
      <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(offset)) {
        fitted.values &lt;-<span class="st"> </span>fitted.values <span class="op">+</span><span class="st"> </span>offset[model.mask]
      }
      <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
        fitted.values &lt;-<span class="st"> </span><span class="kw">exp</span>(fitted.values)<span class="op">/</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(fitted.values))
      }
      <span class="cf">else</span> <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;poisson&quot;</span>) {
        fitted.values &lt;-<span class="st"> </span><span class="kw">exp</span>(fitted.values)
      }
      pred.values[pred.mask] &lt;-<span class="st"> </span>gbm<span class="op">::</span><span class="kw">predict.gbm</span>(model.list[[i]], 
                                                 x.data[pred.mask, , <span class="dt">drop =</span> <span class="ot">FALSE</span>], <span class="dt">n.trees =</span> n.fitted)
      <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(offset)) {
        pred.values[pred.mask] &lt;-<span class="st"> </span>pred.values[pred.mask] <span class="op">+</span><span class="st"> </span>
<span class="st">          </span>offset[pred.mask]
      }
      <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
        pred.values[pred.mask] &lt;-<span class="st"> </span><span class="kw">exp</span>(pred.values[pred.mask])<span class="op">/</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>
<span class="st">                                                                 </span><span class="kw">exp</span>(pred.values[pred.mask]))
      }
      <span class="cf">else</span> <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;poisson&quot;</span>) {
        pred.values[pred.mask] &lt;-<span class="st"> </span><span class="kw">exp</span>(pred.values[pred.mask])
      }
      y_i &lt;-<span class="st"> </span>y.subset
      u_i &lt;-<span class="st"> </span>fitted.values
      weight.fitted &lt;-<span class="st"> </span>site.weights[model.mask]
      training.loss.matrix[i, j] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(y_i, 
                                                  u_i, weight.fitted, <span class="dt">family =</span> family)
      u_i &lt;-<span class="st"> </span>pred.values[pred.mask]
      y_i &lt;-<span class="st"> </span>y.data[pred.mask]
      weight.preds &lt;-<span class="st"> </span>site.weights[pred.mask]
      cv.loss.matrix[i, j] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(y_i, u_i, weight.preds, 
                                            <span class="dt">family =</span> family)
    }
    cv.loss.values &lt;-<span class="st"> </span><span class="kw">apply</span>(cv.loss.matrix, <span class="dv">2</span>, mean)
    <span class="cf">if</span> (j <span class="op">&lt;</span><span class="st"> </span><span class="dv">5</span>) {
      <span class="cf">if</span> (cv.loss.values[j] <span class="op">&gt;</span><span class="st"> </span>cv.loss.values[j <span class="op">-</span><span class="st"> </span><span class="dv">1</span>]) {
        <span class="cf">if</span> (<span class="op">!</span>silent) {
          <span class="kw">cat</span>(<span class="st">&quot;restart model with a smaller learning rate or smaller step size...&quot;</span>)
        }
        <span class="kw">return</span>()
      }
    }
    <span class="cf">if</span> (j <span class="op">&gt;=</span><span class="st"> </span><span class="dv">20</span>) {
      test1 &lt;-<span class="st"> </span><span class="kw">mean</span>(cv.loss.values[(j <span class="op">-</span><span class="st"> </span><span class="dv">9</span>)<span class="op">:</span>j])
      test2 &lt;-<span class="st"> </span><span class="kw">mean</span>(cv.loss.values[(j <span class="op">-</span><span class="st"> </span><span class="dv">19</span>)<span class="op">:</span>(j <span class="op">-</span><span class="st"> </span><span class="dv">9</span>)])
      delta.deviance &lt;-<span class="st"> </span>test2 <span class="op">-</span><span class="st"> </span>test1
    }
    <span class="cf">if</span> (verbose) {
      <span class="kw">cat</span>(n.fitted, <span class="st">&quot; &quot;</span>, <span class="kw">round</span>(cv.loss.values[j], <span class="dv">4</span>), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
      <span class="kw">flush.console</span>()
    }
  }
  training.loss.values &lt;-<span class="st"> </span><span class="kw">apply</span>(training.loss.matrix, <span class="dv">2</span>, mean)
  cv.loss.ses &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="kw">length</span>(cv.loss.values))
  cv.loss.ses &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">apply</span>(cv.loss.matrix, <span class="dv">2</span>, var))<span class="op">/</span><span class="kw">sqrt</span>(n.folds)
  y.bar &lt;-<span class="st"> </span><span class="kw">min</span>(cv.loss.values)
  target.trees &lt;-<span class="st"> </span>trees.fitted[<span class="kw">match</span>(<span class="ot">TRUE</span>, cv.loss.values <span class="op">==</span><span class="st"> </span>
<span class="st">                                       </span>y.bar)]
  <span class="cf">if</span> (plot.main) {
    y.min &lt;-<span class="st"> </span><span class="kw">min</span>(cv.loss.values <span class="op">-</span><span class="st"> </span>cv.loss.ses)
    y.max &lt;-<span class="st"> </span><span class="kw">max</span>(cv.loss.values <span class="op">+</span><span class="st"> </span>cv.loss.ses)
    <span class="cf">if</span> (plot.folds) {
      y.min &lt;-<span class="st"> </span><span class="kw">min</span>(cv.loss.matrix)
      y.max &lt;-<span class="st"> </span><span class="kw">max</span>(cv.loss.matrix)
    }
    <span class="kw">plot</span>(trees.fitted, cv.loss.values, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;holdout deviance&quot;</span>, 
         <span class="dt">xlab =</span> <span class="st">&quot;no. of trees&quot;</span>, <span class="dt">ylim =</span> <span class="kw">c</span>(y.min, y.max), ...)
    <span class="kw">abline</span>(<span class="dt">h =</span> y.bar, <span class="dt">col =</span> <span class="dv">2</span>)
    <span class="kw">lines</span>(trees.fitted, cv.loss.values <span class="op">+</span><span class="st"> </span>cv.loss.ses, <span class="dt">lty =</span> <span class="dv">2</span>)
    <span class="kw">lines</span>(trees.fitted, cv.loss.values <span class="op">-</span><span class="st"> </span>cv.loss.ses, <span class="dt">lty =</span> <span class="dv">2</span>)
    <span class="cf">if</span> (plot.folds) {
      <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n.folds) {
        <span class="kw">lines</span>(trees.fitted, cv.loss.matrix[i, ], <span class="dt">lty =</span> <span class="dv">3</span>)
      }
    }
    <span class="kw">abline</span>(<span class="dt">v =</span> target.trees, <span class="dt">col =</span> <span class="dv">3</span>)
    <span class="kw">title</span>(<span class="kw">paste</span>(sp.name, <span class="st">&quot;, d - &quot;</span>, tree.complexity, <span class="st">&quot;, lr - &quot;</span>, 
                learning.rate, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>))
  }
  cv.deviance.stats &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n.folds)
  cv.roc.stats &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n.folds)
  cv.cor.stats &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n.folds)
  cv.calibration.stats &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">ncol =</span> <span class="dv">5</span>, <span class="dt">nrow =</span> n.folds)
  

  <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
    threshold.stats &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n.folds)
    
    
    
    ############################
    ## JA editions / 08/02/19 ##
    ############################
    
    cv.corr.class  &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n.folds)
    cv.length &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n.folds)
    tss.stat &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n.folds)
        
    ####################
    ## End / 08/02/19 ##
    ####################
    
    
  }
  fitted.matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="dt">nrow =</span> n.cases, <span class="dt">ncol =</span> n.folds)
  fold.fit &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n.cases)
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n.folds) {
    pred.mask &lt;-<span class="st"> </span>selector <span class="op">==</span><span class="st"> </span>i
    model.mask &lt;-<span class="st"> </span>selector <span class="op">!=</span><span class="st"> </span>i
    fits &lt;-<span class="st"> </span>gbm<span class="op">::</span><span class="kw">predict.gbm</span>(model.list[[i]], x.data[model.mask, 
                                                     , <span class="dt">drop =</span> <span class="ot">FALSE</span>], <span class="dt">n.trees =</span> target.trees)
    <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(offset)) {
      fits &lt;-<span class="st"> </span>fits <span class="op">+</span><span class="st"> </span>offset[model.mask]
    }
    <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
      fits &lt;-<span class="st"> </span><span class="kw">exp</span>(fits)<span class="op">/</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(fits))
    } <span class="cf">else</span> <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;poisson&quot;</span>) {
      fits &lt;-<span class="st"> </span><span class="kw">exp</span>(fits)
    }
    fitted.matrix[model.mask, i] &lt;-<span class="st"> </span>fits
    fits &lt;-<span class="st"> </span>gbm<span class="op">::</span><span class="kw">predict.gbm</span>(model.list[[i]], x.data[pred.mask, 
                                                     , <span class="dt">drop =</span> <span class="ot">FALSE</span>], <span class="dt">n.trees =</span> target.trees)
    <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(offset)) 
      fits &lt;-<span class="st"> </span>fits <span class="op">+</span><span class="st"> </span>offset[pred.mask]
    fold.fit[pred.mask] &lt;-<span class="st"> </span>fits
    <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
      fits &lt;-<span class="st"> </span><span class="kw">exp</span>(fits)<span class="op">/</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(fits))
    }<span class="cf">else</span> <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;poisson&quot;</span>) {
      fits &lt;-<span class="st"> </span><span class="kw">exp</span>(fits)
    }
    fitted.matrix[pred.mask, i] &lt;-<span class="st"> </span>fits
    y_i &lt;-<span class="st"> </span>y.data[pred.mask]
    u_i &lt;-<span class="st"> </span>fitted.matrix[pred.mask, i]
    weight.preds &lt;-<span class="st"> </span>site.weights[pred.mask]
    cv.deviance.stats[i] &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(y_i, u_i, weight.preds, 
                                          <span class="dt">family =</span> family)
    cv.cor.stats[i] &lt;-<span class="st"> </span><span class="kw">cor</span>(y_i, u_i)
    <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
      cv.roc.stats[i] &lt;-<span class="st"> </span><span class="kw">.roc</span>(y_i, u_i)
      cv.calibration.stats[i, ] &lt;-<span class="st"> </span><span class="kw">.calibration</span>(y_i, u_i, 
                                                <span class="st">&quot;binomial&quot;</span>)
      threshold.stats[i] &lt;-<span class="st"> </span><span class="kw">approx</span>(<span class="kw">ppoints</span>(u_i), <span class="kw">sort</span>(u_i, 
                                                      <span class="dt">decreasing =</span> T), prevalence)<span class="op">$</span>y
      
      ############################
      ## JA editions / 08/02/19 ##
      ############################
      
      c_i &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>)[<span class="kw">as.factor</span>(u_i <span class="op">&lt;=</span><span class="st"> </span>threshold.stats[i])]
      tab1 &lt;-<span class="st"> </span><span class="kw">table</span>(c_i, y_i)
      
      <span class="co"># Correctly classified test data</span>
      cv.corr.class[i] &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="kw">diag</span>(tab1)) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(tab1)
      
      <span class="co"># % cv / total data</span>
      cv.length[i] &lt;-<span class="st"> </span><span class="kw">table</span>(y_i)[<span class="st">&quot;1&quot;</span>] <span class="op">/</span><span class="st"> </span><span class="kw">table</span>(y.data)[<span class="st">&quot;1&quot;</span>]
      
      <span class="co"># TSS</span>
      <span class="co"># Sensitivity =  TP/(TP + FN) </span>
      <span class="co"># Specificity =  TN/(TN + FP) </span>
      tp &lt;-<span class="st"> </span>tab1[<span class="st">&quot;1&quot;</span>, <span class="st">&quot;1&quot;</span>]
      fn &lt;-<span class="st"> </span>tab1[<span class="st">&quot;0&quot;</span>, <span class="st">&quot;1&quot;</span>]
      tn &lt;-<span class="st"> </span>tab1[<span class="st">&quot;0&quot;</span>, <span class="st">&quot;0&quot;</span>]
      fp &lt;-<span class="st"> </span>tab1[<span class="st">&quot;1&quot;</span>, <span class="st">&quot;0&quot;</span>]
      
      sen &lt;-<span class="st"> </span>tp<span class="op">/</span>(tp <span class="op">+</span><span class="st"> </span>fn)
      spe &lt;-<span class="st"> </span>tn<span class="op">/</span>(tn <span class="op">+</span><span class="st"> </span>fp)

      <span class="co"># TSS</span>
      tss.stat[i] &lt;-<span class="st"> </span>spe <span class="op">+</span><span class="st"> </span>sen <span class="op">-</span><span class="dv">1</span>

      ####################
      ## End / 08/02/19 ##
      ####################
      
      
    }
    <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;poisson&quot;</span>) {
      cv.calibration.stats[i, ] &lt;-<span class="st"> </span><span class="kw">.calibration</span>(y_i, u_i, 
                                                <span class="st">&quot;poisson&quot;</span>)
    }
  }
  fitted.vars &lt;-<span class="st"> </span><span class="kw">apply</span>(fitted.matrix, <span class="dv">1</span>, var, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
  cv.dev &lt;-<span class="st"> </span><span class="kw">mean</span>(cv.deviance.stats, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
  cv.dev.se &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">var</span>(cv.deviance.stats))<span class="op">/</span><span class="kw">sqrt</span>(n.folds)
  cv.cor &lt;-<span class="st"> </span><span class="kw">mean</span>(cv.cor.stats, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
  cv.cor.se &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">var</span>(cv.cor.stats, <span class="dt">use =</span> <span class="st">&quot;complete.obs&quot;</span>))<span class="op">/</span><span class="kw">sqrt</span>(n.folds)
  cv.roc &lt;-<span class="st"> </span><span class="dv">0</span>
  cv.roc.se &lt;-<span class="st"> </span><span class="dv">0</span>
  <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
    cv.roc &lt;-<span class="st"> </span><span class="kw">mean</span>(cv.roc.stats, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
    cv.roc.se &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">var</span>(cv.roc.stats, <span class="dt">use =</span> <span class="st">&quot;complete.obs&quot;</span>))<span class="op">/</span><span class="kw">sqrt</span>(n.folds)
    cv.threshold &lt;-<span class="st"> </span><span class="kw">mean</span>(threshold.stats, <span class="dt">na.rm =</span> T)
    cv.threshold.se &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">var</span>(threshold.stats, <span class="dt">use =</span> <span class="st">&quot;complete.obs&quot;</span>))<span class="op">/</span><span class="kw">sqrt</span>(n.folds)
  }
  cv.calibration &lt;-<span class="st"> </span><span class="dv">0</span>
  cv.calibration.se &lt;-<span class="st"> </span><span class="dv">0</span>
  <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;poisson&quot;</span> <span class="op">|</span><span class="st"> </span>family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
    cv.calibration &lt;-<span class="st"> </span><span class="kw">apply</span>(cv.calibration.stats, <span class="dv">2</span>, mean)
    cv.calibration.se &lt;-<span class="st"> </span><span class="kw">apply</span>(cv.calibration.stats, <span class="dv">2</span>, var)
    cv.calibration.se &lt;-<span class="st"> </span><span class="kw">sqrt</span>(cv.calibration.se)<span class="op">/</span><span class="kw">sqrt</span>(n.folds)
  }
  <span class="cf">if</span> (<span class="kw">is.null</span>(offset)) {
    gbm.call &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;gbm::gbm(y.data ~ .,data=x.data, n.trees = target.trees, interaction.depth = tree.complexity, shrinkage = learning.rate, bag.fraction = bag.fraction, weights = site.weights, distribution = as.character(family), var.monotone = var.monotone, verbose = FALSE)&quot;</span>, 
                      <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
  }
  <span class="cf">else</span> {
    gbm.call &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;gbm::gbm(y.data ~ . + offset(offset),data=x.data, n.trees = target.trees, interaction.depth = tree.complexity, shrinkage = learning.rate, bag.fraction = bag.fraction, weights = site.weights, distribution = as.character(family), var.monotone = var.monotone,  verbose = FALSE)&quot;</span>, 
                      <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
  }
  <span class="cf">if</span> (<span class="op">!</span>silent) {
    <span class="kw">message</span>(<span class="st">&quot;fitting final gbm model with a fixed number of &quot;</span>, 
            target.trees, <span class="st">&quot; trees for &quot;</span>, sp.name)
  }
  gbm.object &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text =</span> gbm.call))
  best.trees &lt;-<span class="st"> </span>target.trees
  gbm.summary &lt;-<span class="st"> </span><span class="kw">summary</span>(gbm.object, <span class="dt">n.trees =</span> target.trees, 
                         <span class="dt">plotit =</span> <span class="ot">FALSE</span>)
  fits &lt;-<span class="st"> </span>gbm<span class="op">::</span><span class="kw">predict.gbm</span>(gbm.object, x.data, <span class="dt">n.trees =</span> target.trees)
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(offset)) 
    fits &lt;-<span class="st"> </span>fits <span class="op">+</span><span class="st"> </span>offset
  <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
    fits &lt;-<span class="st"> </span><span class="kw">exp</span>(fits)<span class="op">/</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(fits))
  }
  <span class="cf">else</span> <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;poisson&quot;</span>) {
    fits &lt;-<span class="st"> </span><span class="kw">exp</span>(fits)
  }
  fitted.values &lt;-<span class="st"> </span>fits
  y_i &lt;-<span class="st"> </span>y.data
  u_i &lt;-<span class="st"> </span>fitted.values
  resid.deviance &lt;-<span class="st"> </span><span class="kw">calc.deviance</span>(y_i, u_i, <span class="dt">weights =</span> site.weights, 
                                  <span class="dt">family =</span> family, <span class="dt">calc.mean =</span> <span class="ot">FALSE</span>)
  self.cor &lt;-<span class="st"> </span><span class="kw">cor</span>(y_i, u_i)
  self.calibration &lt;-<span class="st"> </span><span class="dv">0</span>
  self.roc &lt;-<span class="st"> </span><span class="dv">0</span>
  <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
    deviance.contribs &lt;-<span class="st"> </span>(y_i <span class="op">*</span><span class="st"> </span><span class="kw">log</span>(u_i)) <span class="op">+</span><span class="st"> </span>((<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>y_i) <span class="op">*</span><span class="st"> </span>
<span class="st">                                               </span><span class="kw">log</span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>u_i))
    residuals &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">abs</span>(deviance.contribs <span class="op">*</span><span class="st"> </span><span class="dv">2</span>))
    residuals &lt;-<span class="st"> </span><span class="kw">ifelse</span>((y_i <span class="op">-</span><span class="st"> </span>u_i) <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>, <span class="dv">0</span> <span class="op">-</span><span class="st"> </span>residuals, residuals)
    self.roc &lt;-<span class="st"> </span><span class="kw">.roc</span>(y_i, u_i)
    self.calibration &lt;-<span class="st"> </span><span class="kw">.calibration</span>(y_i, u_i, <span class="st">&quot;binomial&quot;</span>)
    
    
    
    ############################
    ## JA editions / 08/02/19 ##
    ############################
    
    self.th &lt;-<span class="st"> </span><span class="kw">approx</span>(<span class="kw">ppoints</span>(u_i), <span class="kw">sort</span>(u_i, 
                              <span class="dt">decreasing =</span> T), prevalence)<span class="op">$</span>y
    
    ####################
    ## End / 08/02/19 ##
    ####################
    
  }
  <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;poisson&quot;</span>) {
    deviance.contribs &lt;-<span class="st"> </span><span class="kw">ifelse</span>(y_i <span class="op">==</span><span class="st"> </span><span class="dv">0</span>, <span class="dv">0</span>, (y_i <span class="op">*</span><span class="st"> </span><span class="kw">log</span>(y_i<span class="op">/</span>u_i))) <span class="op">-</span><span class="st"> </span>
<span class="st">      </span>(y_i <span class="op">-</span><span class="st"> </span>u_i)
    residuals &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">abs</span>(deviance.contribs <span class="op">*</span><span class="st"> </span><span class="dv">2</span>))
    residuals &lt;-<span class="st"> </span><span class="kw">ifelse</span>((y_i <span class="op">-</span><span class="st"> </span>u_i) <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>, <span class="dv">0</span> <span class="op">-</span><span class="st"> </span>residuals, residuals)
    self.calibration &lt;-<span class="st"> </span><span class="kw">.calibration</span>(y_i, u_i, <span class="st">&quot;poisson&quot;</span>)
  }
  <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;gaussian&quot;</span> <span class="op">|</span><span class="st"> </span>family <span class="op">==</span><span class="st"> &quot;laplace&quot;</span>) {
    residuals &lt;-<span class="st"> </span>y_i <span class="op">-</span><span class="st"> </span>u_i
  }
  mean.resid.deviance &lt;-<span class="st"> </span>resid.deviance<span class="op">/</span>n.cases
  z2 &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
  elapsed.time.minutes &lt;-<span class="st"> </span><span class="kw">round</span>(<span class="kw">as.numeric</span>(z2 <span class="op">-</span><span class="st"> </span>z1)<span class="op">/</span><span class="dv">60</span>, <span class="dv">2</span>)
  <span class="cf">if</span> (verbose) {
    <span class="kw">cat</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;mean total deviance =&quot;</span>, <span class="kw">round</span>(mean.total.deviance, 
                                       <span class="dv">3</span>), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;mean residual deviance =&quot;</span>, <span class="kw">round</span>(mean.resid.deviance, 
                                          <span class="dv">3</span>), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;estimated cv deviance =&quot;</span>, <span class="kw">round</span>(cv.dev, <span class="dv">3</span>), <span class="st">&quot;; se =&quot;</span>, 
        <span class="kw">round</span>(cv.dev.se, <span class="dv">3</span>), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;training data correlation =&quot;</span>, <span class="kw">round</span>(self.cor, <span class="dv">3</span>), 
        <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;cv correlation = &quot;</span>, <span class="kw">round</span>(cv.cor, <span class="dv">3</span>), <span class="st">&quot;; se =&quot;</span>, 
        <span class="kw">round</span>(cv.cor.se, <span class="dv">3</span>), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
      <span class="kw">cat</span>(<span class="st">&quot;training data AUC score =&quot;</span>, <span class="kw">round</span>(self.roc, 
                                             <span class="dv">3</span>), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
      <span class="kw">cat</span>(<span class="st">&quot;cv AUC score =&quot;</span>, <span class="kw">round</span>(cv.roc, <span class="dv">3</span>), <span class="st">&quot;; se =&quot;</span>, 
          <span class="kw">round</span>(cv.roc.se, <span class="dv">3</span>), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    }
    <span class="kw">cat</span>(<span class="st">&quot;elapsed time - &quot;</span>, <span class="kw">round</span>(elapsed.time.minutes, <span class="dv">2</span>), 
        <span class="st">&quot;minutes&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
  }
  <span class="cf">if</span> (n.fitted <span class="op">==</span><span class="st"> </span>max.trees <span class="op">&amp;</span><span class="st"> </span><span class="op">!</span>silent) {
    <span class="kw">cat</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;########### warning ##########&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;maximum tree limit reached - results may not be optimal&quot;</span>, 
        <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;  - refit with faster learning rate or increase maximum number of trees&quot;</span>, 
        <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
  }
  gbm.detail &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">dataframe =</span> data, <span class="dt">gbm.x =</span> gbm.x, <span class="dt">predictor.names =</span> <span class="kw">names</span>(x.data), 
                     <span class="dt">gbm.y =</span> gbm.y, <span class="dt">response.name =</span> sp.name, <span class="dt">offset =</span> offset, 
                     <span class="dt">family =</span> family, <span class="dt">tree.complexity =</span> tree.complexity, <span class="dt">learning.rate =</span> learning.rate, 
                     <span class="dt">bag.fraction =</span> bag.fraction, <span class="dt">cv.folds =</span> n.folds, <span class="dt">prev.stratification =</span> prev.stratify, 
                     <span class="dt">max.fitted =</span> n.fitted, <span class="dt">n.trees =</span> target.trees, <span class="dt">best.trees =</span> target.trees, 
                     <span class="dt">train.fraction =</span> <span class="dv">1</span>, <span class="dt">tolerance.method =</span> tolerance.method, 
                     <span class="dt">tolerance =</span> tolerance, <span class="dt">var.monotone =</span> var.monotone, <span class="dt">date =</span> <span class="kw">date</span>(), 
                     <span class="dt">elapsed.time.minutes =</span> elapsed.time.minutes)
  training.stats &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">null =</span> total.deviance, <span class="dt">mean.null =</span> mean.total.deviance, 
                         <span class="dt">resid =</span> resid.deviance, <span class="dt">mean.resid =</span> mean.resid.deviance, 
                         <span class="dt">correlation =</span> self.cor, <span class="dt">discrimination =</span> self.roc, <span class="dt">calibration =</span> self.calibration)
  cv.stats &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">deviance.mean =</span> cv.dev, <span class="dt">deviance.se =</span> cv.dev.se, 
                   <span class="dt">correlation.mean =</span> cv.cor, <span class="dt">correlation.se =</span> cv.cor.se, 
                   <span class="dt">discrimination.mean =</span> cv.roc, <span class="dt">discrimination.se =</span> cv.roc.se, 
                   <span class="dt">calibration.mean =</span> cv.calibration, <span class="dt">calibration.se =</span> cv.calibration.se)
  <span class="cf">if</span> (family <span class="op">==</span><span class="st"> &quot;bernoulli&quot;</span>) {
    cv.stats<span class="op">$</span>cv.threshold &lt;-<span class="st"> </span>cv.threshold
    cv.stats<span class="op">$</span>cv.threshold.se &lt;-<span class="st"> </span>cv.threshold.se
  }
  gbm.object<span class="op">$</span>gbm.call &lt;-<span class="st"> </span>gbm.detail
  gbm.object<span class="op">$</span>fitted &lt;-<span class="st"> </span>fitted.values
  gbm.object<span class="op">$</span>fitted.vars &lt;-<span class="st"> </span>fitted.vars
  gbm.object<span class="op">$</span>residuals &lt;-<span class="st"> </span>residuals
  gbm.object<span class="op">$</span>contributions &lt;-<span class="st"> </span>gbm.summary
  gbm.object<span class="op">$</span>self.statistics &lt;-<span class="st"> </span>training.stats
  gbm.object<span class="op">$</span>cv.statistics &lt;-<span class="st"> </span>cv.stats
  gbm.object<span class="op">$</span>weights &lt;-<span class="st"> </span>site.weights
  gbm.object<span class="op">$</span>trees.fitted &lt;-<span class="st"> </span>trees.fitted
  gbm.object<span class="op">$</span>training.loss.values &lt;-<span class="st"> </span>training.loss.values
  gbm.object<span class="op">$</span>cv.values &lt;-<span class="st"> </span>cv.loss.values
  gbm.object<span class="op">$</span>cv.loss.ses &lt;-<span class="st"> </span>cv.loss.ses
  gbm.object<span class="op">$</span>cv.loss.matrix &lt;-<span class="st"> </span>cv.loss.matrix
  gbm.object<span class="op">$</span>cv.roc.matrix &lt;-<span class="st"> </span>cv.roc.stats
  
  ############################
  ## JA editions / 08/02/19 ##
  ############################
  
  gbm.object<span class="op">$</span>cv.cor.matrix &lt;-<span class="st"> </span>cv.cor.stats
  gbm.object<span class="op">$</span>cv.th.matrix &lt;-<span class="st"> </span>threshold.stats
  gbm.object<span class="op">$</span>cv.corr.class &lt;-<span class="st"> </span>cv.corr.class
  gbm.object<span class="op">$</span>self.th &lt;-<span class="st"> </span>self.th
  gbm.object<span class="op">$</span>cv.length &lt;-<span class="st"> </span>cv.length
  gbm.object<span class="op">$</span>tss.cv &lt;-<span class="st"> </span>tss.stat
  
  ####################
  ## End / 08/02/19 ##
  ####################
  
  <span class="cf">if</span> (keep.fold.models) {
    gbm.object<span class="op">$</span>fold.models &lt;-<span class="st"> </span>model.list
  }
  <span class="cf">else</span> {
    gbm.object<span class="op">$</span>fold.models &lt;-<span class="st"> </span><span class="ot">NULL</span>
  }
  <span class="cf">if</span> (keep.fold.vector) {
    gbm.object<span class="op">$</span>fold.vector &lt;-<span class="st"> </span>selector
  }
  <span class="cf">else</span> {
    gbm.object<span class="op">$</span>fold.vector &lt;-<span class="st"> </span><span class="ot">NULL</span>
  }
  <span class="cf">if</span> (keep.fold.fit) {
    gbm.object<span class="op">$</span>fold.fit &lt;-<span class="st"> </span>fold.fit
  }
  <span class="cf">else</span> {
    gbm.object<span class="op">$</span>fold.fit &lt;-<span class="st"> </span><span class="ot">NULL</span>
  }
  <span class="kw">return</span>(gbm.object)
}


## II.
## https://github.com/cran/ENMeval/tree/master/R

#########################################################
#########  MAKE BLOCK EVALUATION GROUPS #############
#########################################################

get.block &lt;-<span class="st"> </span><span class="cf">function</span>(occ, bg.coords){
  <span class="co"># SPLIT OCC POINTS INTO FOUR SPATIAL GROUPS</span>
  noccs &lt;-<span class="st"> </span><span class="kw">nrow</span>(occ)
  n1 &lt;-<span class="st"> </span><span class="kw">ceiling</span>(<span class="kw">nrow</span>(occ)<span class="op">/</span><span class="dv">2</span>)
  n2 &lt;-<span class="st"> </span><span class="kw">floor</span>(<span class="kw">nrow</span>(occ)<span class="op">/</span><span class="dv">2</span>)
  n3 &lt;-<span class="st"> </span><span class="kw">ceiling</span>(n1<span class="op">/</span><span class="dv">2</span>)
  n4 &lt;-<span class="st"> </span><span class="kw">ceiling</span>(n2<span class="op">/</span><span class="dv">2</span>)
  grpA &lt;-<span class="st"> </span>occ[<span class="kw">order</span>(occ[, <span class="dv">2</span>]),][<span class="dv">1</span><span class="op">:</span>n1,]
  grpB &lt;-<span class="st"> </span>occ[<span class="kw">rev</span>(<span class="kw">order</span>(occ[, <span class="dv">2</span>])),][<span class="dv">1</span><span class="op">:</span>n2,]
  grp1 &lt;-<span class="st"> </span>grpA[<span class="kw">order</span>(grpA[, <span class="dv">1</span>]),][<span class="dv">1</span><span class="op">:</span>(n3),]
  grp2 &lt;-<span class="st"> </span>grpA[<span class="op">!</span><span class="kw">rownames</span>(grpA)<span class="op">%in%</span><span class="kw">rownames</span>(grp1),]
  grp3 &lt;-<span class="st"> </span>grpB[<span class="kw">order</span>(grpB[, <span class="dv">1</span>]),][<span class="dv">1</span><span class="op">:</span>(n4),]
  grp4 &lt;-<span class="st"> </span>grpB[<span class="op">!</span><span class="kw">rownames</span>(grpB)<span class="op">%in%</span><span class="kw">rownames</span>(grp3),]
  
  <span class="co"># SPLIT BACKGROUND POINTS BASED ON SPATIAL GROUPS</span>
  bvert &lt;-<span class="st"> </span><span class="kw">mean</span>(<span class="kw">max</span>(grp1[, <span class="dv">1</span>]), <span class="kw">min</span>(grp2[, <span class="dv">1</span>])) <span class="op">+</span><span class="st"> </span><span class="fl">0.5</span>
  tvert &lt;-<span class="st"> </span><span class="kw">mean</span>(<span class="kw">max</span>(grp3[, <span class="dv">1</span>]), <span class="kw">min</span>(grp4[, <span class="dv">1</span>])) <span class="op">+</span><span class="st"> </span><span class="fl">0.5</span>
  horz &lt;-<span class="st"> </span><span class="kw">mean</span>(<span class="kw">max</span>(grpA[, <span class="dv">2</span>]), <span class="kw">min</span>(grpB[, <span class="dv">2</span>])) <span class="op">+</span><span class="st"> </span><span class="fl">0.5</span>
  bggrp1 &lt;-<span class="st"> </span>bg.coords[bg.coords[, <span class="dv">2</span>] <span class="op">&lt;=</span><span class="st"> </span>horz <span class="op">&amp;</span><span class="st"> </span>bg.coords[, <span class="dv">1</span>]<span class="op">&lt;</span>bvert,]
  bggrp2 &lt;-<span class="st"> </span>bg.coords[bg.coords[, <span class="dv">2</span>] <span class="op">&lt;</span><span class="st"> </span>horz <span class="op">&amp;</span><span class="st"> </span>bg.coords[, <span class="dv">1</span>]<span class="op">&gt;=</span>bvert,]
  bggrp3 &lt;-<span class="st"> </span>bg.coords[bg.coords[, <span class="dv">2</span>] <span class="op">&gt;</span><span class="st"> </span>horz <span class="op">&amp;</span><span class="st"> </span>bg.coords[, <span class="dv">1</span>]<span class="op">&lt;=</span>tvert,]
  bggrp4 &lt;-<span class="st"> </span>bg.coords[bg.coords[, <span class="dv">2</span>] <span class="op">&gt;=</span><span class="st"> </span>horz <span class="op">&amp;</span><span class="st"> </span>bg.coords[, <span class="dv">1</span>]<span class="op">&gt;</span>tvert,]
  
  rr &lt;-<span class="st"> </span>bg.coords[bg.coords[, <span class="dv">2</span>] <span class="op">&gt;</span><span class="st"> </span>horz <span class="op">&amp;</span><span class="st"> </span>bg.coords[, <span class="dv">1</span>] <span class="op">&lt;=</span><span class="st"> </span>bvert <span class="op">&amp;</span><span class="st"> </span>bg.coords[, <span class="dv">1</span>] <span class="op">&gt;=</span><span class="st"> </span>tvert,]
  
  r &lt;-<span class="st"> </span><span class="kw">data.frame</span>()
  <span class="cf">if</span> (<span class="kw">nrow</span>(grp1) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) grp1<span class="op">$</span>grp &lt;-<span class="st"> </span><span class="dv">1</span>; r &lt;-<span class="st"> </span><span class="kw">rbind</span>(r, grp1)
  <span class="cf">if</span> (<span class="kw">nrow</span>(grp2) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) grp2<span class="op">$</span>grp &lt;-<span class="st"> </span><span class="dv">2</span>; r &lt;-<span class="st"> </span><span class="kw">rbind</span>(r, grp2)
  <span class="cf">if</span> (<span class="kw">nrow</span>(grp3) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) grp3<span class="op">$</span>grp &lt;-<span class="st"> </span><span class="dv">3</span>; r &lt;-<span class="st"> </span><span class="kw">rbind</span>(r, grp3)
  <span class="cf">if</span> (<span class="kw">nrow</span>(grp4) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) grp4<span class="op">$</span>grp &lt;-<span class="st"> </span><span class="dv">4</span>; r &lt;-<span class="st"> </span><span class="kw">rbind</span>(r, grp4)
  occ.grp &lt;-<span class="st"> </span>r[<span class="kw">order</span>(<span class="kw">as.numeric</span>(<span class="kw">rownames</span>(r))),]<span class="op">$</span>grp
  
  bgr &lt;-<span class="st"> </span><span class="kw">data.frame</span>()
  <span class="cf">if</span> (<span class="kw">nrow</span>(bggrp1) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) bggrp1<span class="op">$</span>grp &lt;-<span class="st"> </span><span class="dv">1</span>; bgr &lt;-<span class="st"> </span><span class="kw">rbind</span>(bgr, bggrp1)
  <span class="cf">if</span> (<span class="kw">nrow</span>(bggrp2) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) bggrp2<span class="op">$</span>grp &lt;-<span class="st"> </span><span class="dv">2</span>; bgr &lt;-<span class="st"> </span><span class="kw">rbind</span>(bgr, bggrp2)
  <span class="cf">if</span> (<span class="kw">nrow</span>(bggrp3) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) bggrp3<span class="op">$</span>grp &lt;-<span class="st"> </span><span class="dv">3</span>; bgr &lt;-<span class="st"> </span><span class="kw">rbind</span>(bgr, bggrp3)
  <span class="cf">if</span> (<span class="kw">nrow</span>(bggrp4) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) bggrp4<span class="op">$</span>grp &lt;-<span class="st"> </span><span class="dv">4</span>; bgr &lt;-<span class="st"> </span><span class="kw">rbind</span>(bgr, bggrp4)
  bg.grp &lt;-<span class="st"> </span>bgr[<span class="kw">order</span>(<span class="kw">as.numeric</span>(<span class="kw">rownames</span>(bgr))),]<span class="op">$</span>grp
  
  out &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">occ.grp=</span>occ.grp, <span class="dt">bg.grp=</span>bg.grp)
  <span class="kw">return</span>(out)
}

## III.

<span class="co"># Fonction pour calculer les nouveaux coordonnées issues d&#39;une rotation d&#39;un nuage de points  </span>
rota &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">matxy =</span> MyMat, <span class="dt">theta =</span> pi<span class="op">/</span><span class="dv">3</span>, <span class="dt">center =</span> center){
  
  matxy &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(matxy)
  <span class="kw">colnames</span>(matxy) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)
  
  <span class="co">#3. define a 60 degree counter-clockwise rotation matrix</span>
  R &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="kw">cos</span>(theta), <span class="op">-</span><span class="kw">sin</span>(theta)), 
             <span class="kw">c</span>(<span class="kw">sin</span>(theta), <span class="kw">cos</span>(theta)))
  
  <span class="co"># do the rotation...</span>
  s &lt;-<span class="st"> </span>matxy <span class="co">#- center    # shift points in the plane so that the center of rotation is at the origin</span>
  <span class="cf">for</span>(hh <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(matxy)){
    s[hh, ] &lt;-<span class="st"> </span>matxy[hh,] <span class="op">-</span><span class="st"> </span>center
  }
  
  so &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dt">x =</span> s[,<span class="st">&quot;x&quot;</span>] <span class="op">*</span><span class="st"> </span>R[<span class="dv">1</span>,<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>s[,<span class="st">&quot;y&quot;</span>] <span class="op">*</span><span class="st"> </span>R[<span class="dv">1</span>,<span class="dv">2</span>],
              <span class="dt">y =</span> s[,<span class="st">&quot;x&quot;</span>] <span class="op">*</span><span class="st"> </span>R[<span class="dv">2</span>,<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>s[,<span class="st">&quot;y&quot;</span>] <span class="op">*</span><span class="st"> </span>R[<span class="dv">2</span>,<span class="dv">2</span>])
  
  <span class="co">#so = R %*% s           # apply the rotation about the origin</span>
  <span class="co">#vo = so + center   # shift again so the origin goes back to the desired center of rotation</span>
  
  vo &lt;-<span class="st"> </span>matxy <span class="co">#- center    # shift points in the plane so that the center of rotation is at the origin</span>
  <span class="cf">for</span>(hh <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(matxy)){
    vo[hh, ] &lt;-<span class="st"> </span>so[hh,] <span class="op">+</span><span class="st"> </span>center
  }
  
  <span class="co"># this can be done in one line as:</span>
  <span class="co"># vo = R*(v - center) + center</span>
  <span class="kw">return</span>(vo)
}</code></pre></div>
<p><a href="./course_material/exercises/scripts/">run_yOur_SDM.R</a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(ncdf4)
<span class="kw">library</span>(raster)
<span class="kw">library</span>(dismo)
<span class="kw">library</span>(gbm)

#### Open occurrence records ####
<span class="co">#---------------------------------</span>
occ.sterechinus &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/occurrences_sterechinus.csv&quot;</span>, <span class="dt">header=</span>T, <span class="dt">sep=</span><span class="st">&quot;;&quot;</span>)
<span class="co"># head(occ.sterechinus)</span>

#### Open Environmental descriptors layers and stack them together ####
<span class="co">#-----------------------------------------------------------------------</span>
depth &lt;-<span class="st"> </span><span class="kw">raster</span>(<span class="st">&quot;data/environmental_layers/depth.nc&quot;</span>)
sediments &lt;-<span class="st"> </span><span class="kw">raster</span>(<span class="st">&quot;data/environmental_layers/sediments.nc&quot;</span>)
seafloor_temp_2005_2012_max &lt;-<span class="st"> </span><span class="kw">raster</span>(<span class="st">&quot;data/environmental_layers/seafloor_temp_2005_2012_max.nc&quot;</span>)
POC_2005_2012_max &lt;-<span class="st"> </span><span class="kw">raster</span>(<span class="st">&quot;data/environmental_layers/POC_2005_2012_max.nc&quot;</span>)
seafloor_current_speed &lt;-<span class="st"> </span><span class="kw">raster</span>(<span class="st">&quot;data/environmental_layers/seafloor_current_speed.nc&quot;</span>)

predictors_stack &lt;-<span class="st"> </span><span class="kw">stack</span>(depth,sediments,seafloor_temp_2005_2012_max,POC_2005_2012_max,seafloor_current_speed)

## have a look at your descriptors properties 
<span class="co">#..............................................</span>
<span class="co">#predictors_stack</span>
<span class="co">#plot(predictors_stack)</span>

<span class="co"># have a look at the distribution of occurrences </span>
<span class="co">#.................................................</span>
<span class="co">#plot(depth)</span>
<span class="co">#points(occ.sterechinus[,c(2,1)], pch=20) # longitude first, latitude second</span>

<span class="co">#--------------------------------------------------------------------------------------------------------------</span>
<span class="co"># Open the KDE layer of sampling effort, on which the background data will be sampled (by weighting) </span>
<span class="co"># The KDE (Kernel Density Estimation) is a statistical tool that helps to measure the probability of finding</span>
<span class="co"># an occurrencce on each pixel, according to the set of benthic records sampled in the entire Southern Ocean </span>
<span class="co"># (update from the Biogeographic Atlas of the Southern Ocean)</span>
<span class="co">#--------------------------------------------------------------------------------------------------------------</span>
KDE &lt;-<span class="st"> </span><span class="kw">raster</span>(<span class="st">&quot;data/KDE.asc&quot;</span>)
<span class="co"># on this layer, the continents are defined by pixels containing NA values</span>
<span class="co"># it enables R to recognise later on the areas where the background data shoud </span>
<span class="co"># not be sampled </span>
<span class="co">#-----------------------------------------------------------------------------------------</span>

#### Set up 
<span class="co">#-------------</span>
cv.boot &lt;-<span class="st"> </span><span class="dv">2</span> <span class="co"># number of replicates (# of times models are launched/replicated)</span>
<span class="kw">source</span>(<span class="st">&quot;scripts/Function_gbm.R&quot;</span>)

#### Stack of empty data and matrices to fill
<span class="co">#----------------------------------------------------------</span>

stack.pred&lt;-<span class="kw">subset</span>(predictors_stack,<span class="dv">1</span>);<span class="kw">values</span>(stack.pred)&lt;-<span class="ot">NA</span>
<span class="co">#testvaluesp&lt;-rep(NA,nrow(fichier_data)) ; testvaluesa &lt;- testvaluesp</span>

model_stats &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="dv">6</span>, cv.boot<span class="op">*</span><span class="dv">4</span>,<span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="kw">c</span>(<span class="st">&quot;AUC&quot;</span>, <span class="st">&quot;COR&quot;</span>, <span class="st">&quot;TSS&quot;</span>, <span class="st">&quot;maxSSS&quot;</span>, <span class="st">&quot;valid_test_data&quot;</span>,<span class="st">&quot;prop_test&quot;</span>), <span class="ot">NULL</span>))

<span class="co"># Stores the contribution</span>
contTr &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="kw">dim</span>(predictors_stack)[<span class="dv">3</span>], cv.boot, <span class="dt">dimnames =</span> <span class="kw">list</span>(<span class="kw">names</span>(predictors_stack), <span class="ot">NULL</span>))
n.seed &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>,<span class="dv">60</span>,<span class="dv">1</span>)[<span class="op">-</span><span class="kw">c</span>(<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">17</span>,<span class="dv">28</span>,<span class="dv">32</span>,<span class="dv">41</span>,<span class="dv">45</span>,<span class="dv">46</span>,<span class="dv">48</span>,<span class="dv">53</span>)] <span class="co"># controls and fixes the random sampling (to compare results more accurately) </span>

<span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>cv.boot){

  <span class="co">#------------------------------------------------------------</span>
  #### create the matrix of occurrence-environment 
  <span class="co">#------------------------------------------------</span>
  envi.presences &lt;-<span class="st"> </span><span class="kw">unique</span>(<span class="kw">extract</span> (predictors_stack,occ.sterechinus[,<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>)]))
  presence.data &lt;-<span class="st"> </span>occ.sterechinus[<span class="op">-</span><span class="kw">which</span>(<span class="kw">duplicated</span>(<span class="kw">extract</span>(predictors_stack,occ.sterechinus[,<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>)]))),<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>)]; <span class="kw">colnames</span>(presence.data)&lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;longitude&quot;</span>,<span class="st">&quot;latitude&quot;</span>)
  <span class="co"># the function &#39;unique&#39; enables to remove the duplicates that may be contained in the dataset (occurrences found in a same pixel); &#39;duplicated&#39; aims at spotting which of these rows are similar </span>
  <span class="co">#head(envi.presences)</span>
  <span class="co"># the presence data will be associated to ID=1</span>
  
  <span class="kw">set.seed</span>(n.seed[j])
  <span class="co"># sampling of background data : in the loop, changes at each replicate </span>
  <span class="co"># 1000 background data are randomly sampled in the environment, according to the weighting scheme of the KDE layer </span>
  background_data &lt;-<span class="st"> </span><span class="kw">xyFromCell</span>(KDE, <span class="kw">sample</span>(<span class="kw">which</span>(<span class="op">!</span><span class="kw">is.na</span>(<span class="kw">values</span>(KDE))), <span class="dv">200</span>, <span class="dt">prob=</span><span class="kw">values</span>(KDE)[<span class="op">!</span><span class="kw">is.na</span>(<span class="kw">values</span>(KDE))]))

  <span class="kw">colnames</span>(background_data) &lt;-<span class="st"> </span><span class="kw">colnames</span>(presence.data)
  <span class="co"># extract environmental conditions where the background data are sampled </span>
  envi.background &lt;-<span class="st"> </span><span class="kw">extract</span>(predictors_stack,background_data)
  <span class="co"># the background data will be associated to ID=0</span>

  <span class="co"># Initialise the matrix containing presence, background data and the environmental values associated </span>
  id&lt;-<span class="dv">0</span>;sdmdata.unique&lt;-<span class="dv">0</span>;  id&lt;-<span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>,<span class="kw">nrow</span>(envi.presences)),<span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">nrow</span>(envi.background))) 
  MATRIX_OCC_ENVI&lt;-<span class="kw">data.frame</span>(<span class="kw">cbind</span>(id,<span class="kw">rbind</span>(envi.presences,envi.background)))
  <span class="co">#head(MATRIX_OCC_ENVI)</span>

  <span class="co"># Split of the occurrence-background dataset into folds of test/training data (spatially segregated)</span>
  dat1 &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">cbind</span>(background_data, <span class="dt">Isp=</span><span class="kw">rep</span>(<span class="dv">0</span>,<span class="kw">nrow</span>(background_data))), <span class="kw">cbind</span>(presence.data,<span class="dt">Isp=</span><span class="kw">rep</span>(<span class="dv">1</span>,<span class="kw">nrow</span>(presence.data)))); <span class="kw">colnames</span>(dat1)&lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;longitude&quot;</span>,<span class="st">&quot;latitude&quot;</span>,<span class="st">&quot;Isp&quot;</span>)
  <span class="co">#tail(dat1)</span>
  idP &lt;-<span class="st"> </span><span class="kw">which</span>(dat1<span class="op">$</span>Isp <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) <span class="co">#  id of presence data to split them </span>
  MyFold &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">nrow</span>(dat1)) <span class="co"># an empty box to store the group of the data (1 to 4 afterwards)</span>
  
  <span class="kw">source</span>(<span class="st">&quot;scripts/clock4_crossValidation.R&quot;</span>)
  clock4F &lt;-<span class="st"> </span><span class="kw">clock4</span>(dat1[idP, <span class="kw">c</span>(<span class="st">&quot;longitude&quot;</span>, <span class="st">&quot;latitude&quot;</span>)], dat1[<span class="op">-</span>idP, <span class="kw">c</span>(<span class="st">&quot;longitude&quot;</span>, <span class="st">&quot;latitude&quot;</span>)])
  
  <span class="co"># Extracts the folds</span>
  MyFold[idP] &lt;-<span class="st"> </span>clock4F<span class="op">$</span>occ.grp
  MyFold[<span class="op">-</span>idP] &lt;-<span class="st"> </span>clock4F<span class="op">$</span>bg.coords.grp
  <span class="kw">plot</span>(dat1[,<span class="kw">c</span>(<span class="st">&quot;longitude&quot;</span>, <span class="st">&quot;latitude&quot;</span>)], <span class="dt">pch =</span> <span class="dv">20</span>, <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;red&quot;</span>, <span class="st">&quot;blue&quot;</span>,<span class="st">&quot;black&quot;</span>,<span class="st">&quot;purple&quot;</span>)[<span class="kw">as.factor</span>(MyFold)])
  
  <span class="co">#--------------------------</span>
  #### launch the model  ! 
  <span class="co">#--------------------------</span>
  model.res&lt;-<span class="st"> </span><span class="kw">gbm.step_v2</span> (<span class="dt">data=</span>MATRIX_OCC_ENVI, 
                         <span class="dt">gbm.x =</span> <span class="dv">2</span><span class="op">:</span><span class="kw">ncol</span>(MATRIX_OCC_ENVI),
                         <span class="dt">gbm.y =</span> <span class="dv">1</span>,
                         <span class="dt">family =</span> <span class="st">&quot;bernoulli&quot;</span>,
                         <span class="dt">n.folds=</span><span class="dv">4</span>,
                         <span class="dt">fold.vector =</span> MyFold, 
                         <span class="dt">tree.complexity =</span> <span class="dv">3</span>,
                         <span class="dt">learning.rate =</span> <span class="fl">0.015</span>,
                         <span class="dt">bag.fraction =</span><span class="fl">0.5</span>)

  <span class="co">#------------------------------------------------------------</span>
  #### Extract data and model outputs 
  <span class="co">#------------------------------------------------------------</span>
  <span class="co"># Predictions </span>
  p&lt;-<span class="kw">predict</span>(predictors_stack,model.res,<span class="dt">n.trees=</span>model.res<span class="op">$</span>gbm.call<span class="op">$</span>best.trees,<span class="dt">type=</span><span class="st">&quot;response&quot;</span>, <span class="dt">na.rm=</span>F)
  stack.pred&lt;-<span class="kw">stack</span>(stack.pred,p) <span class="co"># stack all the maps replicates </span>
  
  ########
  ## CV ## (= on CV folds)
  ########
    j_cv &lt;-<span class="st"> </span>((j<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span><span class="st"> </span><span class="dv">4</span><span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>(j<span class="op">*</span><span class="dv">4</span>) <span class="co"># to count the folds </span>
  
  model_stats[<span class="st">&quot;AUC&quot;</span>, j_cv] &lt;-<span class="st"> </span>model.res<span class="op">$</span>cv.roc.matrix
  model_stats[<span class="st">&quot;COR&quot;</span>, j_cv] &lt;-<span class="st"> </span>model.res<span class="op">$</span>cv.cor.matrix
  model_stats[<span class="st">&quot;TSS&quot;</span>, j_cv] &lt;-<span class="st"> </span>model.res<span class="op">$</span>tss.cv
  model_stats[<span class="st">&quot;maxSSS&quot;</span>, j_cv] &lt;-<span class="st"> </span>model.res<span class="op">$</span>cv.th.matrix

  ## correctly classified test data 
  model_stats[<span class="st">&quot;valid_test_data&quot;</span>, j_cv] &lt;-<span class="st"> </span>model.res<span class="op">$</span>cv.corr.class<span class="op">*</span><span class="dv">100</span>
  model_stats[<span class="st">&quot;prop_test&quot;</span>, j_cv] &lt;-<span class="st"> </span>model.res<span class="op">$</span>cv.length<span class="op">*</span><span class="dv">100</span>
  
  <span class="co"># Get contributions </span>
  RI &lt;-<span class="st"> </span><span class="kw">summary</span>(model.res, <span class="dt">plotit =</span> F) <span class="co"># extract the contribution</span>
  contTr[<span class="kw">match</span>(RI<span class="op">$</span>var, <span class="kw">rownames</span>(contTr)), j] &lt;-<span class="st"> </span>RI[,<span class="st">&quot;rel.inf&quot;</span>]

}

<span class="co">#------------------------</span>
#### Maps of predictions 
<span class="co">#------------------------</span>
mean_stack &lt;-<span class="st"> </span>raster<span class="op">::</span><span class="kw">calc</span>(stack.pred, mean, <span class="dt">na.rm=</span>T); mean_stack &lt;-<span class="st"> </span><span class="kw">mask</span>(mean_stack, depth)
<span class="co">#sd_stack &lt;- raster::calc(stack.pred,sd, na.rm=T); sd_stack &lt;- mask(sd_stack, depth)</span>

<span class="co"># you can plot the results </span>
<span class="co">#continent &lt;- read.csv(&quot;data/worldmap.csv&quot;) # add continents lines </span>
<span class="co">#plot(mean_stack) ; points(continent, type=&quot;l&quot;)</span>

<span class="co"># this is an approximate map, if you want to have a nicer representation, you can </span>
<span class="co"># export the ascii document and open it on another software such as Qgis or other</span>
<span class="co"># writeRaster(mean_stack, &quot;results/mean_raster.asc&quot;)</span>
<span class="co"># writeRaster(sd_stack, &quot;results/sd_raster.asc&quot;)</span>

<span class="co">#---------------------</span>
#### Model statistics 
<span class="co">#---------------------</span>
ecM &lt;-<span class="st"> </span><span class="kw">apply</span>(model_stats, <span class="dv">1</span>, mean, <span class="dt">na.rm=</span>T)
ecSD &lt;-<span class="st"> </span><span class="kw">apply</span>(model_stats, <span class="dv">1</span>, sd, <span class="dt">na.rm=</span>T)
ecTot &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">round</span>(ecM, <span class="dv">3</span>), <span class="kw">round</span>(ecSD, <span class="dv">3</span>), <span class="dt">sep =</span> <span class="st">&quot; ± &quot;</span>)
<span class="kw">names</span>(ecTot) &lt;-<span class="st"> </span><span class="kw">names</span>(ecM)

ResF &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">c</span>(ecTot[<span class="st">&quot;AUC&quot;</span>],ecTot[<span class="st">&quot;COR&quot;</span>],ecTot[<span class="st">&quot;TSS&quot;</span>],ecTot[<span class="st">&quot;maxSSS&quot;</span>], ecTot[<span class="st">&quot;valid_test_data&quot;</span>], ecTot[<span class="st">&quot;prop_test&quot;</span>]))
<span class="kw">rownames</span>(ResF) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;AUC&quot;</span>,<span class="st">&quot;COR&quot;</span>,<span class="st">&quot;TSS&quot;</span>, <span class="st">&quot;maxSSS&quot;</span>,  <span class="st">&quot;Correctly classified test data&quot;</span>, <span class="st">&quot;Test data (% of total dataset)&quot;</span>) ; <span class="kw">colnames</span>(ResF) &lt;-<span class="st"> &quot;Model average statistics&quot;</span>

<span class="co"># matrix of raw results </span>
<span class="co">#model_stats</span>
<span class="co"># average values </span>
<span class="co">#ResF</span>

<span class="co"># same, you can export the results </span>
<span class="co">#write.csv(model_stats,&quot;results/model_stats.csv&quot;))</span>

## Contribution of environmental descriptors 
<span class="co"># raw data </span>
<span class="co">#contTr</span>

<span class="co"># calculate the average </span>
CtM &lt;-<span class="st"> </span><span class="kw">apply</span>(contTr, <span class="dv">1</span>, mean)
CtSD &lt;-<span class="st"> </span><span class="kw">apply</span>(contTr, <span class="dv">1</span>, sd)
CtTot &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">round</span>(CtM, <span class="dv">3</span>), <span class="kw">round</span>(CtSD, <span class="dv">3</span>), <span class="dt">sep =</span> <span class="st">&quot; ± &quot;</span>)
<span class="kw">names</span>(CtTot) &lt;-<span class="st"> </span><span class="kw">names</span>(CtM)

CtTot &lt;-<span class="st"> </span><span class="kw">data.frame</span>(CtTot) ; <span class="kw">colnames</span>(CtTot) &lt;-<span class="st"> &quot;Contribution (%) of environmental descriptors to the model&quot;</span>
<span class="co">#write.csv(CtTot, &quot;results/avg_contribution.csv&quot;)</span>


####---------------------------------------------------------------------------
####---------------------------------------------------------------------------
### CALCULATE EXTRAPOLATION 
<span class="co"># Multivariate Environmental Similarity Surface (Elith et al. 2010) </span>
<span class="co"># envi.presences &lt;- unique(extract (predictors_stack,occ.sterechinus[,c(2,1)]))</span>
<span class="co"># x &lt;- dismo::mess(predictors_stack, na.omit(envi.presences))</span>
<span class="co"># </span>
<span class="co"># y &lt;- x; values(y)&lt;- values(x)&gt;0  # refers to Elith et al. (2010): when the calculated MESS values are negative, it means that it is extrapolating (outside of boundaries)</span>
<span class="co"># y &lt;- reclassify(y,cbind(FALSE,0)) # extrapolation area </span>
<span class="co"># y &lt;- reclassify(y,cbind(TRUE,1))  # non extrapolation, inside the boundaries of calibration</span>
<span class="co"># </span>
<span class="co"># plot(y)</span>

####---------------------------------------------------------------------------
####---------------------------------------------------------------------------</code></pre></div>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="recent-and-past-application-of-sdms.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="sdm-algorithms.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection",
"scroll_highlight": true
},
"toc_depth": 3
});
});
</script>

</body>

</html>
